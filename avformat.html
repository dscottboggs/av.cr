<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>/usr/include/x86_64-linux-gnu/libavformat/avformat.h</title>
<link rel="stylesheet" type="text/css" href="highlight.css">
</head>
<body class="hl">
<pre class="hl"><span class="hl com">/*</span>
<span class="hl com"> * copyright (c) 2001 Fabrice Bellard</span>
<span class="hl com"> *</span>
<span class="hl com"> * This file is part of FFmpeg.</span>
<span class="hl com"> *</span>
<span class="hl com"> * FFmpeg is free software; you can redistribute it and/or</span>
<span class="hl com"> * modify it under the terms of the GNU Lesser General Public</span>
<span class="hl com"> * License as published by the Free Software Foundation; either</span>
<span class="hl com"> * version 2.1 of the License, or (at your option) any later version.</span>
<span class="hl com"> *</span>
<span class="hl com"> * FFmpeg is distributed in the hope that it will be useful,</span>
<span class="hl com"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="hl com"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="hl com"> * Lesser General Public License for more details.</span>
<span class="hl com"> *</span>
<span class="hl com"> * You should have received a copy of the GNU Lesser General Public</span>
<span class="hl com"> * License along with FFmpeg; if not, write to the Free Software</span>
<span class="hl com"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span>
<span class="hl com"> */</span>

<span class="hl ppc">#ifndef AVFORMAT_AVFORMAT_H</span>
<span class="hl ppc">#define AVFORMAT_AVFORMAT_H</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;file</span>
<span class="hl com"> * &#64;ingroup libavf</span>
<span class="hl com"> * Main libavformat public API header</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;defgroup libavf libavformat</span>
<span class="hl com"> * I/O and Muxing/Demuxing Library</span>
<span class="hl com"> *</span>
<span class="hl com"> * Libavformat (lavf) is a library for dealing with various media container</span>
<span class="hl com"> * formats. Its main two purposes are demuxing - i.e. splitting a media file</span>
<span class="hl com"> * into component streams, and the reverse process of muxing - writing supplied</span>
<span class="hl com"> * data in a specified container format. It also has an &#64;ref lavf_io</span>
<span class="hl com"> * &quot;I/O module&quot; which supports a number of protocols for accessing the data (e.g.</span>
<span class="hl com"> * file, tcp, http and others). Before using lavf, you need to call</span>
<span class="hl com"> * av_register_all() to register all compiled muxers, demuxers and protocols.</span>
<span class="hl com"> * Unless you are absolutely sure you won&apos;t use libavformat&apos;s network</span>
<span class="hl com"> * capabilities, you should also call avformat_network_init().</span>
<span class="hl com"> *</span>
<span class="hl com"> * A supported input format is described by an AVInputFormat struct, conversely</span>
<span class="hl com"> * an output format is described by AVOutputFormat. You can iterate over all</span>
<span class="hl com"> * registered input/output formats using the av_iformat_next() /</span>
<span class="hl com"> * av_oformat_next() functions. The protocols layer is not part of the public</span>
<span class="hl com"> * API, so you can only get the names of supported protocols with the</span>
<span class="hl com"> * avio_enum_protocols() function.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Main lavf structure used for both muxing and demuxing is AVFormatContext,</span>
<span class="hl com"> * which exports all information about the file being read or written. As with</span>
<span class="hl com"> * most Libavformat structures, its size is not part of public ABI, so it cannot be</span>
<span class="hl com"> * allocated on stack or directly with av_malloc(). To create an</span>
<span class="hl com"> * AVFormatContext, use avformat_alloc_context() (some functions, like</span>
<span class="hl com"> * avformat_open_input() might do that for you).</span>
<span class="hl com"> *</span>
<span class="hl com"> * Most importantly an AVFormatContext contains:</span>
<span class="hl com"> * &#64;li the &#64;ref AVFormatContext.iformat &quot;input&quot; or &#64;ref AVFormatContext.oformat</span>
<span class="hl com"> * &quot;output&quot; format. It is either autodetected or set by user for input;</span>
<span class="hl com"> * always set by user for output.</span>
<span class="hl com"> * &#64;li an &#64;ref AVFormatContext.streams &quot;array&quot; of AVStreams, which describe all</span>
<span class="hl com"> * elementary streams stored in the file. AVStreams are typically referred to</span>
<span class="hl com"> * using their index in this array.</span>
<span class="hl com"> * &#64;li an &#64;ref AVFormatContext.pb &quot;I/O context&quot;. It is either opened by lavf or</span>
<span class="hl com"> * set by user for input, always set by user for output (unless you are dealing</span>
<span class="hl com"> * with an AVFMT_NOFILE format).</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;section lavf_options Passing options to (de)muxers</span>
<span class="hl com"> * It is possible to configure lavf muxers and demuxers using the &#64;ref avoptions</span>
<span class="hl com"> * mechanism. Generic (format-independent) libavformat options are provided by</span>
<span class="hl com"> * AVFormatContext, they can be examined from a user program by calling</span>
<span class="hl com"> * av_opt_next() / av_opt_find() on an allocated AVFormatContext (or its AVClass</span>
<span class="hl com"> * from avformat_get_class()). Private (format-specific) options are provided by</span>
<span class="hl com"> * AVFormatContext.priv_data if and only if AVInputFormat.priv_class /</span>
<span class="hl com"> * AVOutputFormat.priv_class of the corresponding format struct is non-NULL.</span>
<span class="hl com"> * Further options may be provided by the &#64;ref AVFormatContext.pb &quot;I/O context&quot;,</span>
<span class="hl com"> * if its AVClass is non-NULL, and the protocols layer. See the discussion on</span>
<span class="hl com"> * nesting in &#64;ref avoptions documentation to learn how to access those.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;section urls</span>
<span class="hl com"> * URL strings in libavformat are made of a scheme/protocol, a &apos;:&apos;, and a</span>
<span class="hl com"> * scheme specific string. URLs without a scheme and &apos;:&apos; used for local files</span>
<span class="hl com"> * are supported but deprecated. &quot;file:&quot; should be used for local files.</span>
<span class="hl com"> *</span>
<span class="hl com"> * It is important that the scheme string is not taken from untrusted</span>
<span class="hl com"> * sources without checks.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Note that some schemes/protocols are quite powerful, allowing access to</span>
<span class="hl com"> * both local and remote files, parts of them, concatenations of them, local</span>
<span class="hl com"> * audio and video devices and so on.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;defgroup lavf_decoding Demuxing</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * Demuxers read a media file and split it into chunks of data (&#64;em packets). A</span>
<span class="hl com"> * &#64;ref AVPacket &quot;packet&quot; contains one or more encoded frames which belongs to a</span>
<span class="hl com"> * single elementary stream. In the lavf API this process is represented by the</span>
<span class="hl com"> * avformat_open_input() function for opening a file, av_read_frame() for</span>
<span class="hl com"> * reading a single packet and finally avformat_close_input(), which does the</span>
<span class="hl com"> * cleanup.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;section lavf_decoding_open Opening a media file</span>
<span class="hl com"> * The minimum information required to open a file is its URL, which</span>
<span class="hl com"> * is passed to avformat_open_input(), as in the following code:</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * const char    *url = &quot;file:in.mp3&quot;;</span>
<span class="hl com"> * AVFormatContext *s = NULL;</span>
<span class="hl com"> * int ret = avformat_open_input(&amp;s, url, NULL, NULL);</span>
<span class="hl com"> * if (ret &lt; 0)</span>
<span class="hl com"> *     abort();</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> * The above code attempts to allocate an AVFormatContext, open the</span>
<span class="hl com"> * specified file (autodetecting the format) and read the header, exporting the</span>
<span class="hl com"> * information stored there into s. Some formats do not have a header or do not</span>
<span class="hl com"> * store enough information there, so it is recommended that you call the</span>
<span class="hl com"> * avformat_find_stream_info() function which tries to read and decode a few</span>
<span class="hl com"> * frames to find missing information.</span>
<span class="hl com"> *</span>
<span class="hl com"> * In some cases you might want to preallocate an AVFormatContext yourself with</span>
<span class="hl com"> * avformat_alloc_context() and do some tweaking on it before passing it to</span>
<span class="hl com"> * avformat_open_input(). One such case is when you want to use custom functions</span>
<span class="hl com"> * for reading input data instead of lavf internal I/O layer.</span>
<span class="hl com"> * To do that, create your own AVIOContext with avio_alloc_context(), passing</span>
<span class="hl com"> * your reading callbacks to it. Then set the &#64;em pb field of your</span>
<span class="hl com"> * AVFormatContext to newly created AVIOContext.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Since the format of the opened file is in general not known until after</span>
<span class="hl com"> * avformat_open_input() has returned, it is not possible to set demuxer private</span>
<span class="hl com"> * options on a preallocated context. Instead, the options should be passed to</span>
<span class="hl com"> * avformat_open_input() wrapped in an AVDictionary:</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * AVDictionary *options = NULL;</span>
<span class="hl com"> * av_dict_set(&amp;options, &quot;video_size&quot;, &quot;640x480&quot;, 0);</span>
<span class="hl com"> * av_dict_set(&amp;options, &quot;pixel_format&quot;, &quot;rgb24&quot;, 0);</span>
<span class="hl com"> *</span>
<span class="hl com"> * if (avformat_open_input(&amp;s, url, NULL, &amp;options) &lt; 0)</span>
<span class="hl com"> *     abort();</span>
<span class="hl com"> * av_dict_free(&amp;options);</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> * This code passes the private options &apos;video_size&apos; and &apos;pixel_format&apos; to the</span>
<span class="hl com"> * demuxer. They would be necessary for e.g. the rawvideo demuxer, since it</span>
<span class="hl com"> * cannot know how to interpret raw video data otherwise. If the format turns</span>
<span class="hl com"> * out to be something different than raw video, those options will not be</span>
<span class="hl com"> * recognized by the demuxer and therefore will not be applied. Such unrecognized</span>
<span class="hl com"> * options are then returned in the options dictionary (recognized options are</span>
<span class="hl com"> * consumed). The calling program can handle such unrecognized options as it</span>
<span class="hl com"> * wishes, e.g.</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * AVDictionaryEntry *e;</span>
<span class="hl com"> * if (e = av_dict_get(options, &quot;&quot;, NULL, AV_DICT_IGNORE_SUFFIX)) {</span>
<span class="hl com"> *     fprintf(stderr, &quot;Option %s not recognized by the demuxer.\n&quot;, e-&gt;key);</span>
<span class="hl com"> *     abort();</span>
<span class="hl com"> * }</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> *</span>
<span class="hl com"> * After you have finished reading the file, you must close it with</span>
<span class="hl com"> * avformat_close_input(). It will free everything associated with the file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;section lavf_decoding_read Reading from an opened file</span>
<span class="hl com"> * Reading data from an opened AVFormatContext is done by repeatedly calling</span>
<span class="hl com"> * av_read_frame() on it. Each call, if successful, will return an AVPacket</span>
<span class="hl com"> * containing encoded data for one AVStream, identified by</span>
<span class="hl com"> * AVPacket.stream_index. This packet may be passed straight into the libavcodec</span>
<span class="hl com"> * decoding functions avcodec_send_packet() or avcodec_decode_subtitle2() if the</span>
<span class="hl com"> * caller wishes to decode the data.</span>
<span class="hl com"> *</span>
<span class="hl com"> * AVPacket.pts, AVPacket.dts and AVPacket.duration timing information will be</span>
<span class="hl com"> * set if known. They may also be unset (i.e. AV_NOPTS_VALUE for</span>
<span class="hl com"> * pts/dts, 0 for duration) if the stream does not provide them. The timing</span>
<span class="hl com"> * information will be in AVStream.time_base units, i.e. it has to be</span>
<span class="hl com"> * multiplied by the timebase to convert them to seconds.</span>
<span class="hl com"> *</span>
<span class="hl com"> * If AVPacket.buf is set on the returned packet, then the packet is</span>
<span class="hl com"> * allocated dynamically and the user may keep it indefinitely.</span>
<span class="hl com"> * Otherwise, if AVPacket.buf is NULL, the packet data is backed by a</span>
<span class="hl com"> * static storage somewhere inside the demuxer and the packet is only valid</span>
<span class="hl com"> * until the next av_read_frame() call or closing the file. If the caller</span>
<span class="hl com"> * requires a longer lifetime, av_dup_packet() will make an av_malloc()ed copy</span>
<span class="hl com"> * of it.</span>
<span class="hl com"> * In both cases, the packet must be freed with av_packet_unref() when it is no</span>
<span class="hl com"> * longer needed.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;section lavf_decoding_seek Seeking</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;defgroup lavf_encoding Muxing</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * Muxers take encoded data in the form of &#64;ref AVPacket &quot;AVPackets&quot; and write</span>
<span class="hl com"> * it into files or other output bytestreams in the specified container format.</span>
<span class="hl com"> *</span>
<span class="hl com"> * The main API functions for muxing are avformat_write_header() for writing the</span>
<span class="hl com"> * file header, av_write_frame() / av_interleaved_write_frame() for writing the</span>
<span class="hl com"> * packets and av_write_trailer() for finalizing the file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * At the beginning of the muxing process, the caller must first call</span>
<span class="hl com"> * avformat_alloc_context() to create a muxing context. The caller then sets up</span>
<span class="hl com"> * the muxer by filling the various fields in this context:</span>
<span class="hl com"> *</span>
<span class="hl com"> * - The &#64;ref AVFormatContext.oformat &quot;oformat&quot; field must be set to select the</span>
<span class="hl com"> *   muxer that will be used.</span>
<span class="hl com"> * - Unless the format is of the AVFMT_NOFILE type, the &#64;ref AVFormatContext.pb</span>
<span class="hl com"> *   &quot;pb&quot; field must be set to an opened IO context, either returned from</span>
<span class="hl com"> *   avio_open2() or a custom one.</span>
<span class="hl com"> * - Unless the format is of the AVFMT_NOSTREAMS type, at least one stream must</span>
<span class="hl com"> *   be created with the avformat_new_stream() function. The caller should fill</span>
<span class="hl com"> *   the &#64;ref AVStream.codecpar &quot;stream codec parameters&quot; information, such as the</span>
<span class="hl com"> *   codec &#64;ref AVCodecParameters.codec_type &quot;type&quot;, &#64;ref AVCodecParameters.codec_id</span>
<span class="hl com"> *   &quot;id&quot; and other parameters (e.g. width / height, the pixel or sample format,</span>
<span class="hl com"> *   etc.) as known. The &#64;ref AVStream.time_base &quot;stream timebase&quot; should</span>
<span class="hl com"> *   be set to the timebase that the caller desires to use for this stream (note</span>
<span class="hl com"> *   that the timebase actually used by the muxer can be different, as will be</span>
<span class="hl com"> *   described later).</span>
<span class="hl com"> * - It is advised to manually initialize only the relevant fields in</span>
<span class="hl com"> *   AVCodecParameters, rather than using &#64;ref avcodec_parameters_copy() during</span>
<span class="hl com"> *   remuxing: there is no guarantee that the codec context values remain valid</span>
<span class="hl com"> *   for both input and output format contexts.</span>
<span class="hl com"> * - The caller may fill in additional information, such as &#64;ref</span>
<span class="hl com"> *   AVFormatContext.metadata &quot;global&quot; or &#64;ref AVStream.metadata &quot;per-stream&quot;</span>
<span class="hl com"> *   metadata, &#64;ref AVFormatContext.chapters &quot;chapters&quot;, &#64;ref</span>
<span class="hl com"> *   AVFormatContext.programs &quot;programs&quot;, etc. as described in the</span>
<span class="hl com"> *   AVFormatContext documentation. Whether such information will actually be</span>
<span class="hl com"> *   stored in the output depends on what the container format and the muxer</span>
<span class="hl com"> *   support.</span>
<span class="hl com"> *</span>
<span class="hl com"> * When the muxing context is fully set up, the caller must call</span>
<span class="hl com"> * avformat_write_header() to initialize the muxer internals and write the file</span>
<span class="hl com"> * header. Whether anything actually is written to the IO context at this step</span>
<span class="hl com"> * depends on the muxer, but this function must always be called. Any muxer</span>
<span class="hl com"> * private options must be passed in the options parameter to this function.</span>
<span class="hl com"> *</span>
<span class="hl com"> * The data is then sent to the muxer by repeatedly calling av_write_frame() or</span>
<span class="hl com"> * av_interleaved_write_frame() (consult those functions&apos; documentation for</span>
<span class="hl com"> * discussion on the difference between them; only one of them may be used with</span>
<span class="hl com"> * a single muxing context, they should not be mixed). Do note that the timing</span>
<span class="hl com"> * information on the packets sent to the muxer must be in the corresponding</span>
<span class="hl com"> * AVStream&apos;s timebase. That timebase is set by the muxer (in the</span>
<span class="hl com"> * avformat_write_header() step) and may be different from the timebase</span>
<span class="hl com"> * requested by the caller.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Once all the data has been written, the caller must call av_write_trailer()</span>
<span class="hl com"> * to flush any buffered packets and finalize the output file, then close the IO</span>
<span class="hl com"> * context (if any) and finally free the muxing context with</span>
<span class="hl com"> * avformat_free_context().</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;defgroup lavf_io I/O Read/Write</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;section lavf_io_dirlist Directory listing</span>
<span class="hl com"> * The directory listing API makes it possible to list files on remote servers.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Some of possible use cases:</span>
<span class="hl com"> * - an &quot;open file&quot; dialog to choose files from a remote location,</span>
<span class="hl com"> * - a recursive media finder providing a player with an ability to play all</span>
<span class="hl com"> * files from a given directory.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;subsection lavf_io_dirlist_open Opening a directory</span>
<span class="hl com"> * At first, a directory needs to be opened by calling avio_open_dir()</span>
<span class="hl com"> * supplied with a URL and, optionally, ::AVDictionary containing</span>
<span class="hl com"> * protocol-specific parameters. The function returns zero or positive</span>
<span class="hl com"> * integer and allocates AVIODirContext on success.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * AVIODirContext *ctx = NULL;</span>
<span class="hl com"> * if (avio_open_dir(&amp;ctx, &quot;smb://example.com/some_dir&quot;, NULL) &lt; 0) {</span>
<span class="hl com"> *     fprintf(stderr, &quot;Cannot open directory.\n&quot;);</span>
<span class="hl com"> *     abort();</span>
<span class="hl com"> * }</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> *</span>
<span class="hl com"> * This code tries to open a sample directory using smb protocol without</span>
<span class="hl com"> * any additional parameters.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;subsection lavf_io_dirlist_read Reading entries</span>
<span class="hl com"> * Each directory&apos;s entry (i.e. file, another directory, anything else</span>
<span class="hl com"> * within ::AVIODirEntryType) is represented by AVIODirEntry.</span>
<span class="hl com"> * Reading consecutive entries from an opened AVIODirContext is done by</span>
<span class="hl com"> * repeatedly calling avio_read_dir() on it. Each call returns zero or</span>
<span class="hl com"> * positive integer if successful. Reading can be stopped right after the</span>
<span class="hl com"> * NULL entry has been read -- it means there are no entries left to be</span>
<span class="hl com"> * read. The following code reads all entries from a directory associated</span>
<span class="hl com"> * with ctx and prints their names to standard output.</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * AVIODirEntry *entry = NULL;</span>
<span class="hl com"> * for (;;) {</span>
<span class="hl com"> *     if (avio_read_dir(ctx, &amp;entry) &lt; 0) {</span>
<span class="hl com"> *         fprintf(stderr, &quot;Cannot list directory.\n&quot;);</span>
<span class="hl com"> *         abort();</span>
<span class="hl com"> *     }</span>
<span class="hl com"> *     if (!entry)</span>
<span class="hl com"> *         break;</span>
<span class="hl com"> *     printf(&quot;%s\n&quot;, entry-&gt;name);</span>
<span class="hl com"> *     avio_free_directory_entry(&amp;entry);</span>
<span class="hl com"> * }</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;defgroup lavf_codec Demuxers</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;defgroup lavf_codec_native Native Demuxers</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> * &#64;defgroup lavf_codec_wrappers External library wrappers</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> * &#64;defgroup lavf_protos I/O Protocols</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> * &#64;defgroup lavf_internal Internal</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl ppc">#include &lt;time.h&gt;</span>
<span class="hl ppc">#include &lt;stdio.h&gt;</span>  <span class="hl com">/* FILE */</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;libavcodec/avcodec.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;libavutil/dict.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;libavutil/log.h&quot;</span><span class="hl ppc"></span>

<span class="hl ppc">#include</span> <span class="hl pps">&quot;avio.h&quot;</span><span class="hl ppc"></span>
<span class="hl ppc">#include</span> <span class="hl pps">&quot;libavformat/version.h&quot;</span><span class="hl ppc"></span>

<span class="hl kwb">struct</span> AVFormatContext<span class="hl opt">;</span>

<span class="hl kwb">struct</span> AVDeviceInfoList<span class="hl opt">;</span>
<span class="hl kwb">struct</span> AVDeviceCapabilitiesQuery<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;defgroup metadata_api Public Metadata API</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * &#64;ingroup libavf</span>
<span class="hl com"> * The metadata API allows libavformat to export metadata tags to a client</span>
<span class="hl com"> * application when demuxing. Conversely it allows a client application to</span>
<span class="hl com"> * set metadata when muxing.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Metadata is exported or set as pairs of key/value strings in the &apos;metadata&apos;</span>
<span class="hl com"> * fields of the AVFormatContext, AVStream, AVChapter and AVProgram structs</span>
<span class="hl com"> * using the &#64;ref lavu_dict &quot;AVDictionary&quot; API. Like all strings in FFmpeg,</span>
<span class="hl com"> * metadata is assumed to be UTF-8 encoded Unicode. Note that metadata</span>
<span class="hl com"> * exported by demuxers isn&apos;t checked to be valid UTF-8 in most cases.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Important concepts to keep in mind:</span>
<span class="hl com"> * -  Keys are unique; there can never be 2 tags with the same key. This is</span>
<span class="hl com"> *    also meant semantically, i.e., a demuxer should not knowingly produce</span>
<span class="hl com"> *    several keys that are literally different but semantically identical.</span>
<span class="hl com"> *    E.g., key=Author5, key=Author6. In this example, all authors must be</span>
<span class="hl com"> *    placed in the same tag.</span>
<span class="hl com"> * -  Metadata is flat, not hierarchical; there are no subtags. If you</span>
<span class="hl com"> *    want to store, e.g., the email address of the child of producer Alice</span>
<span class="hl com"> *    and actor Bob, that could have key=alice_and_bobs_childs_email_address.</span>
<span class="hl com"> * -  Several modifiers can be applied to the tag name. This is done by</span>
<span class="hl com"> *    appending a dash character (&apos;-&apos;) and the modifier name in the order</span>
<span class="hl com"> *    they appear in the list below -- e.g. foo-eng-sort, not foo-sort-eng.</span>
<span class="hl com"> *    -  language -- a tag whose value is localized for a particular language</span>
<span class="hl com"> *       is appended with the ISO 639-2/B 3-letter language code.</span>
<span class="hl com"> *       For example: Author-ger=Michael, Author-eng=Mike</span>
<span class="hl com"> *       The original/default language is in the unqualified &quot;Author&quot; tag.</span>
<span class="hl com"> *       A demuxer should set a default if it sets any translated tag.</span>
<span class="hl com"> *    -  sorting  -- a modified version of a tag that should be used for</span>
<span class="hl com"> *       sorting will have &apos;-sort&apos; appended. E.g. artist=&quot;The Beatles&quot;,</span>
<span class="hl com"> *       artist-sort=&quot;Beatles, The&quot;.</span>
<span class="hl com"> * - Some protocols and demuxers support metadata updates. After a successful</span>
<span class="hl com"> *   call to av_read_packet(), AVFormatContext.event_flags or AVStream.event_flags</span>
<span class="hl com"> *   will be updated to indicate if metadata changed. In order to detect metadata</span>
<span class="hl com"> *   changes on a stream, you need to loop through all streams in the AVFormatContext</span>
<span class="hl com"> *   and check their individual event_flags.</span>
<span class="hl com"> *</span>
<span class="hl com"> * -  Demuxers attempt to export metadata in a generic format, however tags</span>
<span class="hl com"> *    with no generic equivalents are left as they are stored in the container.</span>
<span class="hl com"> *    Follows a list of generic tag names:</span>
<span class="hl com"> *</span>
<span class="hl com"> &#64;verbatim</span>
<span class="hl com"> album        -- name of the set this work belongs to</span>
<span class="hl com"> album_artist -- main creator of the set/album, if different from artist.</span>
<span class="hl com">                 e.g. &quot;Various Artists&quot; for compilation albums.</span>
<span class="hl com"> artist       -- main creator of the work</span>
<span class="hl com"> comment      -- any additional description of the file.</span>
<span class="hl com"> composer     -- who composed the work, if different from artist.</span>
<span class="hl com"> copyright    -- name of copyright holder.</span>
<span class="hl com"> creation_time-- date when the file was created, preferably in ISO 8601.</span>
<span class="hl com"> date         -- date when the work was created, preferably in ISO 8601.</span>
<span class="hl com"> disc         -- number of a subset, e.g. disc in a multi-disc collection.</span>
<span class="hl com"> encoder      -- name/settings of the software/hardware that produced the file.</span>
<span class="hl com"> encoded_by   -- person/group who created the file.</span>
<span class="hl com"> filename     -- original name of the file.</span>
<span class="hl com"> genre        -- &lt;self-evident&gt;.</span>
<span class="hl com"> language     -- main language in which the work is performed, preferably</span>
<span class="hl com">                 in ISO 639-2 format. Multiple languages can be specified by</span>
<span class="hl com">                 separating them with commas.</span>
<span class="hl com"> performer    -- artist who performed the work, if different from artist.</span>
<span class="hl com">                 E.g for &quot;Also sprach Zarathustra&quot;, artist would be &quot;Richard</span>
<span class="hl com">                 Strauss&quot; and performer &quot;London Philharmonic Orchestra&quot;.</span>
<span class="hl com"> publisher    -- name of the label/publisher.</span>
<span class="hl com"> service_name     -- name of the service in broadcasting (channel name).</span>
<span class="hl com"> service_provider -- name of the service provider in broadcasting.</span>
<span class="hl com"> title        -- name of the work.</span>
<span class="hl com"> track        -- number of this work in the set, can be in form current/total.</span>
<span class="hl com"> variant_bitrate -- the total bitrate of the bitrate variant that the current stream is part of</span>
<span class="hl com"> &#64;endverbatim</span>
<span class="hl com"> *</span>
<span class="hl com"> * Look in the examples section for an application example how to use the Metadata API.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl com">/* packet functions */</span>


<span class="hl com">/**</span>
<span class="hl com"> * Allocate and read the payload of a packet and initialize its</span>
<span class="hl com"> * fields with default values.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s    associated IO context</span>
<span class="hl com"> * &#64;param pkt packet</span>
<span class="hl com"> * &#64;param size desired payload size</span>
<span class="hl com"> * &#64;return &gt;0 (read size) if OK, AVERROR_xxx otherwise</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_get_packet</span><span class="hl opt">(</span>AVIOContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>


<span class="hl com">/**</span>
<span class="hl com"> * Read data and append it to the current content of the AVPacket.</span>
<span class="hl com"> * If pkt-&gt;size is 0 this is identical to av_get_packet.</span>
<span class="hl com"> * Note that this uses av_grow_packet and thus involves a realloc</span>
<span class="hl com"> * which is inefficient. Thus this function should only be used</span>
<span class="hl com"> * when there is no reasonable way to know (an upper bound of)</span>
<span class="hl com"> * the final size.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s    associated IO context</span>
<span class="hl com"> * &#64;param pkt packet</span>
<span class="hl com"> * &#64;param size amount of data to read</span>
<span class="hl com"> * &#64;return &gt;0 (read size) if OK, AVERROR_xxx otherwise, previous data</span>
<span class="hl com"> *         will not be lost even if an error occurs.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_append_packet</span><span class="hl opt">(</span>AVIOContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>

<span class="hl ppc">#if FF_API_LAVF_FRAC</span>
<span class="hl com">/*************************************************/</span>
<span class="hl com">/* fractional numbers for exact pts handling */</span>

<span class="hl com">/**</span>
<span class="hl com"> * The exact value of the fractional number is: &apos;val + num / den&apos;.</span>
<span class="hl com"> * num is assumed to be 0 &lt;= num &lt; den.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVFrac <span class="hl opt">{</span>
    <span class="hl kwb">int64_t</span> val<span class="hl opt">,</span> num<span class="hl opt">,</span> den<span class="hl opt">;</span>
<span class="hl opt">}</span> AVFrac<span class="hl opt">;</span>
<span class="hl ppc">#endif</span>

<span class="hl com">/*************************************************/</span>
<span class="hl com">/* input/output formats */</span>

<span class="hl kwb">struct</span> AVCodecTag<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * This structure contains the data a format has to probe a file.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVProbeData <span class="hl opt">{</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">;</span>
    <span class="hl kwb">unsigned char</span> <span class="hl opt">*</span>buf<span class="hl opt">;</span> <span class="hl com">/**&lt; Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */</span>
    <span class="hl kwb">int</span> buf_size<span class="hl opt">;</span>       <span class="hl com">/**&lt; Size of buf except extra allocated bytes */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>mime_type<span class="hl opt">;</span> <span class="hl com">/**&lt; mime_type, when known. */</span>
<span class="hl opt">}</span> AVProbeData<span class="hl opt">;</span>

<span class="hl ppc">#define AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span>
<span class="hl ppc">#define AVPROBE_SCORE_STREAM_RETRY (AVPROBE_SCORE_MAX/4-1)</span>

<span class="hl ppc">#define AVPROBE_SCORE_EXTENSION  50</span> <span class="hl slc">///&lt; score for file extension</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVPROBE_SCORE_MIME       75</span> <span class="hl slc">///&lt; score for file mime type</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVPROBE_SCORE_MAX       100</span> <span class="hl slc">///&lt; maximum score</span>
<span class="hl ppc"></span>
<span class="hl ppc">#define AVPROBE_PADDING_SIZE 32</span>             <span class="hl slc">///&lt; extra allocated bytes at the end of the probe buffer</span>
<span class="hl ppc"></span>
<span class="hl slc">/// Demuxer will use avio_open, no opened file should be provided by the caller.</span>
<span class="hl ppc">#define AVFMT_NOFILE        0x0001</span>
<span class="hl ppc">#define AVFMT_NEEDNUMBER    0x0002</span> <span class="hl com">/**&lt; Needs &apos;%d&apos; in filename. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_SHOW_IDS      0x0008</span> <span class="hl com">/**&lt; Show format stream IDs numbers. */</span><span class="hl ppc"></span>
<span class="hl ppc">#if FF_API_LAVF_FMT_RAWPICTURE</span>
<span class="hl ppc">#define AVFMT_RAWPICTURE    0x0020</span> <span class="hl com">/**&lt; Format wants AVPicture structure for</span>
<span class="hl com">                                      raw picture data. &#64;deprecated Not used anymore */</span><span class="hl ppc"></span>
<span class="hl ppc">#endif</span>
<span class="hl ppc">#define AVFMT_GLOBALHEADER  0x0040</span> <span class="hl com">/**&lt; Format wants global header. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NOTIMESTAMPS  0x0080</span> <span class="hl com">/**&lt; Format does not need / have any timestamps. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_GENERIC_INDEX 0x0100</span> <span class="hl com">/**&lt; Use generic index building code. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_TS_DISCONT    0x0200</span> <span class="hl com">/**&lt; Format allows timestamp discontinuities. Note, muxers always require valid (monotone) timestamps */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_VARIABLE_FPS  0x0400</span> <span class="hl com">/**&lt; Format allows variable fps. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NODIMENSIONS  0x0800</span> <span class="hl com">/**&lt; Format does not need width/height */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NOSTREAMS     0x1000</span> <span class="hl com">/**&lt; Format does not require any streams */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NOBINSEARCH   0x2000</span> <span class="hl com">/**&lt; Format does not allow to fall back on binary search via read_timestamp */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NOGENSEARCH   0x4000</span> <span class="hl com">/**&lt; Format does not allow to fall back on generic search */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_NO_BYTE_SEEK  0x8000</span> <span class="hl com">/**&lt; Format does not allow seeking by bytes */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_ALLOW_FLUSH  0x10000</span> <span class="hl com">/**&lt; Format allows flushing. If not set, the muxer will not receive a NULL packet in the write_packet function. */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_TS_NONSTRICT 0x20000</span> <span class="hl com">/**&lt; Format does not require strictly</span>
<span class="hl com">                                        increasing timestamps, but they must</span>
<span class="hl com">                                        still be monotonic */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AVFMT_TS_NEGATIVE  0x40000</span> <span class="hl com">/**&lt; Format allows muxing negative</span>
<span class="hl com">                                        timestamps. If not set the timestamp</span>
<span class="hl com">                                        will be shifted in av_write_frame and</span>
<span class="hl com">                                        av_interleaved_write_frame so they</span>
<span class="hl com">                                        start from 0.</span>
<span class="hl com">                                        The user or muxer can override this through</span>
<span class="hl com">                                        AVFormatContext.avoid_negative_ts</span>
<span class="hl com">                                        */</span><span class="hl ppc"></span>

<span class="hl ppc">#define AVFMT_SEEK_TO_PTS   0x4000000</span> <span class="hl com">/**&lt; Seeking is based on PTS */</span><span class="hl ppc"></span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;addtogroup lavf_encoding</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVOutputFormat <span class="hl opt">{</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>name<span class="hl opt">;</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Descriptive name for the format, meant to be more human-readable</span>
<span class="hl com">     * than name. You should use the NULL_IF_CONFIG_SMALL() macro</span>
<span class="hl com">     * to define it.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>long_name<span class="hl opt">;</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>mime_type<span class="hl opt">;</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>extensions<span class="hl opt">;</span> <span class="hl com">/**&lt; comma-separated filename extensions */</span>
    <span class="hl com">/* output support */</span>
    <span class="hl kwb">enum</span> AVCodecID audio_codec<span class="hl opt">;</span>    <span class="hl com">/**&lt; default audio codec */</span>
    <span class="hl kwb">enum</span> AVCodecID video_codec<span class="hl opt">;</span>    <span class="hl com">/**&lt; default video codec */</span>
    <span class="hl kwb">enum</span> AVCodecID subtitle_codec<span class="hl opt">;</span> <span class="hl com">/**&lt; default subtitle codec */</span>
    <span class="hl com">/**</span>
<span class="hl com">     * can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,</span>
<span class="hl com">     * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,</span>
<span class="hl com">     * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,</span>
<span class="hl com">     * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> flags<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * List of supported codec_id-codec_tag pairs, ordered by &quot;better</span>
<span class="hl com">     * choice first&quot;. The arrays are all terminated by AV_CODEC_ID_NONE.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">*</span>codec_tag<span class="hl opt">;</span>


    <span class="hl kwb">const</span> AVClass <span class="hl opt">*</span>priv_class<span class="hl opt">;</span> <span class="hl slc">///&lt; AVClass for the private context</span>

    <span class="hl com">/*****************************************************************</span>
<span class="hl com">     * No fields below this line are part of the public API. They</span>
<span class="hl com">     * may not be used outside of libavformat and can be changed and</span>
<span class="hl com">     * removed at will.</span>
<span class="hl com">     * New public fields should be added right above.</span>
<span class="hl com">     *****************************************************************</span>
<span class="hl com">     */</span>
    <span class="hl kwb">struct</span> AVOutputFormat <span class="hl opt">*</span>next<span class="hl opt">;</span>
    <span class="hl com">/**</span>
<span class="hl com">     * size of private data so that it can be allocated in the wrapper</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> priv_data_size<span class="hl opt">;</span>

    <span class="hl kwb">int</span> <span class="hl opt">(*</span>write_header<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,</span>
<span class="hl com">     * pkt can be NULL in order to flush data buffered in the muxer.</span>
<span class="hl com">     * When flushing, return 0 if there still is more data to flush,</span>
<span class="hl com">     * or 1 if everything was flushed and there is no more buffered</span>
<span class="hl com">     * data.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>write_packet<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>write_trailer<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Currently only used to set pixel format if not YUV420P.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>interleave_packet<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span> AVPacket <span class="hl opt">*</span>out<span class="hl opt">,</span>
                             AVPacket <span class="hl opt">*</span>in<span class="hl opt">,</span> <span class="hl kwb">int</span> flush<span class="hl opt">);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Test if the given codec can be stored in this container.</span>
<span class="hl com">     *</span>
<span class="hl com">     * &#64;return 1 if the codec is supported, 0 if it is not.</span>
<span class="hl com">     *         A negative number if unknown.</span>
<span class="hl com">     *         MKTAG(&apos;A&apos;, &apos;P&apos;, &apos;I&apos;, &apos;C&apos;) if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>query_codec<span class="hl opt">)(</span><span class="hl kwb">enum</span> AVCodecID id<span class="hl opt">,</span> <span class="hl kwb">int</span> std_compliance<span class="hl opt">);</span>

    <span class="hl kwb">void</span> <span class="hl opt">(*</span>get_output_timestamp<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream<span class="hl opt">,</span>
                                 <span class="hl kwb">int64_t</span> <span class="hl opt">*</span>dts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> <span class="hl opt">*</span>wall<span class="hl opt">);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Allows sending messages from application to device.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>control_message<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> type<span class="hl opt">,</span>
                           <span class="hl kwb">void</span> <span class="hl opt">*</span>data<span class="hl opt">,</span> <span class="hl kwb">size_t</span> data_size<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Write an uncoded AVFrame.</span>
<span class="hl com">     *</span>
<span class="hl com">     * See av_write_uncoded_frame() for details.</span>
<span class="hl com">     *</span>
<span class="hl com">     * The library will free *frame afterwards, but the muxer can prevent it</span>
<span class="hl com">     * by setting the pointer to NULL.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>write_uncoded_frame<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span>
                               AVFrame <span class="hl opt">**</span>frame<span class="hl opt">,</span> <span class="hl kwb">unsigned</span> flags<span class="hl opt">);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Returns device list with it properties.</span>
<span class="hl com">     * &#64;see avdevice_list_devices() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>get_device_list<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceInfoList <span class="hl opt">*</span>device_list<span class="hl opt">);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Initialize device capabilities submodule.</span>
<span class="hl com">     * &#64;see avdevice_capabilities_create() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>create_device_capabilities<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceCapabilitiesQuery <span class="hl opt">*</span>caps<span class="hl opt">);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Free device capabilities submodule.</span>
<span class="hl com">     * &#64;see avdevice_capabilities_free() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>free_device_capabilities<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceCapabilitiesQuery <span class="hl opt">*</span>caps<span class="hl opt">);</span>
    <span class="hl kwb">enum</span> AVCodecID data_codec<span class="hl opt">;</span> <span class="hl com">/**&lt; default data codec */</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Initialize format. May allocate data here, and set any AVFormatContext or</span>
<span class="hl com">     * AVStream parameters that need to be set before packets are sent.</span>
<span class="hl com">     * This method must not write output.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure</span>
<span class="hl com">     *</span>
<span class="hl com">     * Any allocations made here must be freed in deinit().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>init<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Deinitialize format. If present, this is called whenever the muxer is being</span>
<span class="hl com">     * destroyed, regardless of whether or not the header has been written.</span>
<span class="hl com">     *</span>
<span class="hl com">     * If a trailer is being written, this is called after write_trailer().</span>
<span class="hl com">     *</span>
<span class="hl com">     * This is called if init() fails as well.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">void</span> <span class="hl opt">(*</span>deinit<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Set up any necessary bitstream filtering and extract any extra data needed</span>
<span class="hl com">     * for the global header.</span>
<span class="hl com">     * Return 0 if more packets from this stream must be checked; 1 if not.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>check_bitstream<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span> <span class="hl kwb">const</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>
<span class="hl opt">}</span> AVOutputFormat<span class="hl opt">;</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;addtogroup lavf_decoding</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVInputFormat <span class="hl opt">{</span>
    <span class="hl com">/**</span>
<span class="hl com">     * A comma separated list of short names for the format. New names</span>
<span class="hl com">     * may be appended with a minor bump.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>name<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Descriptive name for the format, meant to be more human-readable</span>
<span class="hl com">     * than name. You should use the NULL_IF_CONFIG_SMALL() macro</span>
<span class="hl com">     * to define it.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>long_name<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,</span>
<span class="hl com">     * AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,</span>
<span class="hl com">     * AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> flags<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * If extensions are defined, then no probe is done. You should</span>
<span class="hl com">     * usually not use extension format guessing because it is not</span>
<span class="hl com">     * reliable enough</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>extensions<span class="hl opt">;</span>

    <span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">*</span>codec_tag<span class="hl opt">;</span>

    <span class="hl kwb">const</span> AVClass <span class="hl opt">*</span>priv_class<span class="hl opt">;</span> <span class="hl slc">///&lt; AVClass for the private context</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Comma-separated list of mime types.</span>
<span class="hl com">     * It is used check for matching mime types while probing.</span>
<span class="hl com">     * &#64;see av_probe_input_format2</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const char</span> <span class="hl opt">*</span>mime_type<span class="hl opt">;</span>

    <span class="hl com">/*****************************************************************</span>
<span class="hl com">     * No fields below this line are part of the public API. They</span>
<span class="hl com">     * may not be used outside of libavformat and can be changed and</span>
<span class="hl com">     * removed at will.</span>
<span class="hl com">     * New public fields should be added right above.</span>
<span class="hl com">     *****************************************************************</span>
<span class="hl com">     */</span>
    <span class="hl kwb">struct</span> AVInputFormat <span class="hl opt">*</span>next<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Raw demuxers store their codec ID here.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> raw_codec_id<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Size of private data so that it can be allocated in the wrapper.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> priv_data_size<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Tell if a given file has a chance of being parsed as this format.</span>
<span class="hl com">     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes</span>
<span class="hl com">     * big so you do not have to check for that unless you need more.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_probe<span class="hl opt">)(</span>AVProbeData <span class="hl opt">*);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Read the format header and initialize the AVFormatContext</span>
<span class="hl com">     * structure. Return 0 if OK. &apos;avformat_new_stream&apos; should be</span>
<span class="hl com">     * called to create new streams.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_header<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Read one packet and put it in &apos;pkt&apos;. pts and flags are also</span>
<span class="hl com">     * set. &apos;avformat_new_stream&apos; can be called only if the flag</span>
<span class="hl com">     * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a</span>
<span class="hl com">     * background thread).</span>
<span class="hl com">     * &#64;return 0 on success, &lt; 0 on error.</span>
<span class="hl com">     *         When returning an error, pkt must not have been allocated</span>
<span class="hl com">     *         or must be freed before returning</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_packet<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Close the stream. The AVFormatContext and AVStreams are not</span>
<span class="hl com">     * freed by this function</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_close<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Seek to a given timestamp relative to the frames in</span>
<span class="hl com">     * stream component stream_index.</span>
<span class="hl com">     * &#64;param stream_index Must not be -1.</span>
<span class="hl com">     * &#64;param flags Selects which direction should be preferred if no exact</span>
<span class="hl com">     *              match is available.</span>
<span class="hl com">     * &#64;return &gt;= 0 on success (but not necessarily the new offset)</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_seek<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*,</span>
                     <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> timestamp<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Get the next timestamp in stream[stream_index].time_base units.</span>
<span class="hl com">     * &#64;return the timestamp or AV_NOPTS_VALUE if an error occurred</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> <span class="hl opt">(*</span>read_timestamp<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span>
                              <span class="hl kwb">int64_t</span> <span class="hl opt">*</span>pos<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> pos_limit<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Start/resume playing - only meaningful if using a network-based format</span>
<span class="hl com">     * (RTSP).</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_play<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Pause playing - only meaningful if using a network-based format</span>
<span class="hl com">     * (RTSP).</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_pause<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Seek to timestamp ts.</span>
<span class="hl com">     * Seeking will be done so that the point from which all active streams</span>
<span class="hl com">     * can be presented successfully will be closest to ts and within min/max_ts.</span>
<span class="hl com">     * Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>read_seek2<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> min_ts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> ts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> max_ts<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Returns device list with it properties.</span>
<span class="hl com">     * &#64;see avdevice_list_devices() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>get_device_list<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceInfoList <span class="hl opt">*</span>device_list<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Initialize device capabilities submodule.</span>
<span class="hl com">     * &#64;see avdevice_capabilities_create() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>create_device_capabilities<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceCapabilitiesQuery <span class="hl opt">*</span>caps<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Free device capabilities submodule.</span>
<span class="hl com">     * &#64;see avdevice_capabilities_free() for more details.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>free_device_capabilities<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">struct</span> AVDeviceCapabilitiesQuery <span class="hl opt">*</span>caps<span class="hl opt">);</span>
<span class="hl opt">}</span> AVInputFormat<span class="hl opt">;</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl kwb">enum</span> AVStreamParseType <span class="hl opt">{</span>
    AVSTREAM_PARSE_NONE<span class="hl opt">,</span>
    AVSTREAM_PARSE_FULL<span class="hl opt">,</span>       <span class="hl com">/**&lt; full parsing and repack */</span>
    AVSTREAM_PARSE_HEADERS<span class="hl opt">,</span>    <span class="hl com">/**&lt; Only parse headers, do not repack. */</span>
    AVSTREAM_PARSE_TIMESTAMPS<span class="hl opt">,</span> <span class="hl com">/**&lt; full parsing and interpolation of timestamps for frames not starting on a packet boundary */</span>
    AVSTREAM_PARSE_FULL_ONCE<span class="hl opt">,</span>  <span class="hl com">/**&lt; full parsing and repack of the first frame only, only implemented for H.264 currently */</span>
    AVSTREAM_PARSE_FULL_RAW<span class="hl opt">=</span><span class="hl kwd">MKTAG</span><span class="hl opt">(</span><span class="hl num">0</span><span class="hl opt">,</span><span class="hl str">&apos;R&apos;</span><span class="hl opt">,</span><span class="hl str">&apos;A&apos;</span><span class="hl opt">,</span><span class="hl str">&apos;W&apos;</span><span class="hl opt">),</span>       <span class="hl com">/**&lt; full parsing and repack with timestamp and position generation by parser for raw</span>
<span class="hl com">                                                             this assumes that each packet in the file contains no demuxer level headers and</span>
<span class="hl com">                                                             just codec level data, otherwise position generation would fail */</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVIndexEntry <span class="hl opt">{</span>
    <span class="hl kwb">int64_t</span> pos<span class="hl opt">;</span>
    <span class="hl kwb">int64_t</span> timestamp<span class="hl opt">;</span>        <span class="hl com">/**&lt;</span>
<span class="hl com">                               * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available</span>
<span class="hl com">                               * when seeking to this entry. That means preferable PTS on keyframe based formats.</span>
<span class="hl com">                               * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better</span>
<span class="hl com">                               * is known</span>
<span class="hl com">                               */</span>
<span class="hl ppc">#define AVINDEX_KEYFRAME 0x0001</span>
<span class="hl ppc">#define AVINDEX_DISCARD_FRAME  0x0002</span>    <span class="hl com">/**</span>
<span class="hl com">                                          * Flag is used to indicate which frame should be discarded after decoding.</span>
<span class="hl com">                                          */</span><span class="hl ppc"></span>
    <span class="hl kwb">int</span> flags<span class="hl opt">:</span><span class="hl num">2</span><span class="hl opt">;</span>
    <span class="hl kwb">int</span> size<span class="hl opt">:</span><span class="hl num">30</span><span class="hl opt">;</span> <span class="hl slc">//Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).</span>
    <span class="hl kwb">int</span> min_distance<span class="hl opt">;</span>         <span class="hl com">/**&lt; Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */</span>
<span class="hl opt">}</span> AVIndexEntry<span class="hl opt">;</span>

<span class="hl ppc">#define AV_DISPOSITION_DEFAULT   0x0001</span>
<span class="hl ppc">#define AV_DISPOSITION_DUB       0x0002</span>
<span class="hl ppc">#define AV_DISPOSITION_ORIGINAL  0x0004</span>
<span class="hl ppc">#define AV_DISPOSITION_COMMENT   0x0008</span>
<span class="hl ppc">#define AV_DISPOSITION_LYRICS    0x0010</span>
<span class="hl ppc">#define AV_DISPOSITION_KARAOKE   0x0020</span>

<span class="hl com">/**</span>
<span class="hl com"> * Track should be used during playback by default.</span>
<span class="hl com"> * Useful for subtitle track that should be displayed</span>
<span class="hl com"> * even when user did not explicitly ask for subtitles.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AV_DISPOSITION_FORCED    0x0040</span>
<span class="hl ppc">#define AV_DISPOSITION_HEARING_IMPAIRED  0x0080</span>  <span class="hl com">/**&lt; stream for hearing impaired audiences */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AV_DISPOSITION_VISUAL_IMPAIRED   0x0100</span>  <span class="hl com">/**&lt; stream for visual impaired audiences */</span><span class="hl ppc"></span>
<span class="hl ppc">#define AV_DISPOSITION_CLEAN_EFFECTS     0x0200</span>  <span class="hl com">/**&lt; stream without voice */</span><span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * The stream is stored in the file as an attached picture/&quot;cover art&quot; (e.g.</span>
<span class="hl com"> * APIC frame in ID3v2). The first (usually only) packet associated with it</span>
<span class="hl com"> * will be returned among the first few packets read from the file unless</span>
<span class="hl com"> * seeking takes place. It can also be accessed at any time in</span>
<span class="hl com"> * AVStream.attached_pic.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AV_DISPOSITION_ATTACHED_PIC      0x0400</span>
<span class="hl com">/**</span>
<span class="hl com"> * The stream is sparse, and contains thumbnail images, often corresponding</span>
<span class="hl com"> * to chapter markers. Only ever used with AV_DISPOSITION_ATTACHED_PIC.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AV_DISPOSITION_TIMED_THUMBNAILS  0x0800</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVStreamInternal AVStreamInternal<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * To specify text track kind (different from subtitles default).</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AV_DISPOSITION_CAPTIONS     0x10000</span>
<span class="hl ppc">#define AV_DISPOSITION_DESCRIPTIONS 0x20000</span>
<span class="hl ppc">#define AV_DISPOSITION_METADATA     0x40000</span>

<span class="hl com">/**</span>
<span class="hl com"> * Options for behavior on timestamp wrap detection.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AV_PTS_WRAP_IGNORE      0</span>   <span class="hl slc">///&lt; ignore the wrap</span>
<span class="hl ppc"></span><span class="hl ppc">#define AV_PTS_WRAP_ADD_OFFSET  1</span>   <span class="hl slc">///&lt; add the format specific offset on wrap detection</span>
<span class="hl ppc"></span><span class="hl ppc">#define AV_PTS_WRAP_SUB_OFFSET  -1</span>  <span class="hl slc">///&lt; subtract the format specific offset on wrap detection</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * Stream structure.</span>
<span class="hl com"> * New fields can be added to the end with minor version bumps.</span>
<span class="hl com"> * Removal, reordering and changes to existing fields require a major</span>
<span class="hl com"> * version bump.</span>
<span class="hl com"> * sizeof(AVStream) must not be used outside libav*.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVStream <span class="hl opt">{</span>
    <span class="hl kwb">int</span> index<span class="hl opt">;</span>    <span class="hl com">/**&lt; stream index in AVFormatContext */</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Format-specific stream ID.</span>
<span class="hl com">     * decoding: set by libavformat</span>
<span class="hl com">     * encoding: set by the user, replaced by libavformat if left unset</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> id<span class="hl opt">;</span>
<span class="hl ppc">#if FF_API_LAVF_AVCTX</span>
    <span class="hl com">/**</span>
<span class="hl com">     * &#64;deprecated use the codecpar struct instead</span>
<span class="hl com">     */</span>
    attribute_deprecated
    AVCodecContext <span class="hl opt">*</span>codec<span class="hl opt">;</span>
<span class="hl ppc">#endif</span>
    <span class="hl kwb">void</span> <span class="hl opt">*</span>priv_data<span class="hl opt">;</span>

<span class="hl ppc">#if FF_API_LAVF_FRAC</span>
    <span class="hl com">/**</span>
<span class="hl com">     * &#64;deprecated this field is unused</span>
<span class="hl com">     */</span>
    attribute_deprecated
    <span class="hl kwb">struct</span> AVFrac pts<span class="hl opt">;</span>
<span class="hl ppc">#endif</span>

    <span class="hl com">/**</span>
<span class="hl com">     * This is the fundamental unit of time (in seconds) in terms</span>
<span class="hl com">     * of which frame timestamps are represented.</span>
<span class="hl com">     *</span>
<span class="hl com">     * decoding: set by libavformat</span>
<span class="hl com">     * encoding: May be set by the caller before avformat_write_header() to</span>
<span class="hl com">     *           provide a hint to the muxer about the desired timebase. In</span>
<span class="hl com">     *           avformat_write_header(), the muxer will overwrite this field</span>
<span class="hl com">     *           with the timebase that will actually be used for the timestamps</span>
<span class="hl com">     *           written into the file (which may or may not be related to the</span>
<span class="hl com">     *           user-provided one, depending on the format).</span>
<span class="hl com">     */</span>
    AVRational time_base<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.</span>
<span class="hl com">     * Only set this if you are absolutely 100% sure that the value you set</span>
<span class="hl com">     * it to really is the pts of the first frame.</span>
<span class="hl com">     * This may be undefined (AV_NOPTS_VALUE).</span>
<span class="hl com">     * &#64;note The ASF header does NOT contain a correct start_time the ASF</span>
<span class="hl com">     * demuxer must NOT set this.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> start_time<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Decoding: duration of the stream, in stream time base.</span>
<span class="hl com">     * If a source file does not specify a duration, but does specify</span>
<span class="hl com">     * a bitrate, this value will be estimated from bitrate and file size.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Encoding: May be set by the caller before avformat_write_header() to</span>
<span class="hl com">     * provide a hint to the muxer about the estimated duration.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> duration<span class="hl opt">;</span>

    <span class="hl kwb">int64_t</span> nb_frames<span class="hl opt">;</span>                 <span class="hl slc">///&lt; number of frames in this stream if known or 0</span>

    <span class="hl kwb">int</span> disposition<span class="hl opt">;</span> <span class="hl com">/**&lt; AV_DISPOSITION_* bit field */</span>

    <span class="hl kwb">enum</span> AVDiscard discard<span class="hl opt">;</span> <span class="hl slc">///&lt; Selects which packets can be discarded at will and do not need to be demuxed.</span>

    <span class="hl com">/**</span>
<span class="hl com">     * sample aspect ratio (0 if unknown)</span>
<span class="hl com">     * - encoding: Set by user.</span>
<span class="hl com">     * - decoding: Set by libavformat.</span>
<span class="hl com">     */</span>
    AVRational sample_aspect_ratio<span class="hl opt">;</span>

    AVDictionary <span class="hl opt">*</span>metadata<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Average framerate</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: May be set by libavformat when creating the stream or in</span>
<span class="hl com">     *             avformat_find_stream_info().</span>
<span class="hl com">     * - muxing: May be set by the caller before avformat_write_header().</span>
<span class="hl com">     */</span>
    AVRational avg_frame_rate<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet</span>
<span class="hl com">     * will contain the attached picture.</span>
<span class="hl com">     *</span>
<span class="hl com">     * decoding: set by libavformat, must not be modified by the caller.</span>
<span class="hl com">     * encoding: unused</span>
<span class="hl com">     */</span>
    AVPacket attached_pic<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * An array of side data that applies to the whole stream (i.e. the</span>
<span class="hl com">     * container does not allow it to change between packets).</span>
<span class="hl com">     *</span>
<span class="hl com">     * There may be no overlap between the side data in this array and side data</span>
<span class="hl com">     * in the packets. I.e. a given side data is either exported by the muxer</span>
<span class="hl com">     * (demuxing) / set by the caller (muxing) in this array, then it never</span>
<span class="hl com">     * appears in the packets, or the side data is exported / sent through</span>
<span class="hl com">     * the packets (always in the first packet where the value becomes known or</span>
<span class="hl com">     * changes), then it does not appear in this array.</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: Set by libavformat when the stream is created.</span>
<span class="hl com">     * - muxing: May be set by the caller before avformat_write_header().</span>
<span class="hl com">     *</span>
<span class="hl com">     * Freed by libavformat in avformat_free_context().</span>
<span class="hl com">     *</span>
<span class="hl com">     * &#64;see av_format_inject_global_side_data()</span>
<span class="hl com">     */</span>
    AVPacketSideData <span class="hl opt">*</span>side_data<span class="hl opt">;</span>
    <span class="hl com">/**</span>
<span class="hl com">     * The number of elements in the AVStream.side_data array.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span>            nb_side_data<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Flags for the user to detect events happening on the stream. Flags must</span>
<span class="hl com">     * be cleared by the user once the event has been handled.</span>
<span class="hl com">     * A combination of AVSTREAM_EVENT_FLAG_*.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> event_flags<span class="hl opt">;</span>
<span class="hl ppc">#define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001</span> <span class="hl slc">///&lt; The call resulted in updated metadata.</span>
<span class="hl ppc"></span>
    <span class="hl com">/*****************************************************************</span>
<span class="hl com">     * All fields below this line are not part of the public API. They</span>
<span class="hl com">     * may not be used outside of libavformat and can be changed and</span>
<span class="hl com">     * removed at will.</span>
<span class="hl com">     * Internal note: be aware that physically removing these fields</span>
<span class="hl com">     * will break ABI. Replace removed fields with dummy fields, and</span>
<span class="hl com">     * add new fields to AVStreamInternal.</span>
<span class="hl com">     *****************************************************************</span>
<span class="hl com">     */</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Stream information used internally by avformat_find_stream_info()</span>
<span class="hl com">     */</span>
<span class="hl ppc">#define MAX_STD_TIMEBASES (30*12+30+3+6)</span>
    <span class="hl kwb">struct</span> <span class="hl opt">{</span>
        <span class="hl kwb">int64_t</span> last_dts<span class="hl opt">;</span>
        <span class="hl kwb">int64_t</span> duration_gcd<span class="hl opt">;</span>
        <span class="hl kwb">int</span> duration_count<span class="hl opt">;</span>
        <span class="hl kwb">int64_t</span> rfps_duration_sum<span class="hl opt">;</span>
        <span class="hl kwb">double</span> <span class="hl opt">(*</span>duration_error<span class="hl opt">)[</span><span class="hl num">2</span><span class="hl opt">][</span>MAX_STD_TIMEBASES<span class="hl opt">];</span>
        <span class="hl kwb">int64_t</span> codec_info_duration<span class="hl opt">;</span>
        <span class="hl kwb">int64_t</span> codec_info_duration_fields<span class="hl opt">;</span>

        <span class="hl com">/**</span>
<span class="hl com">         * 0  -&gt; decoder has not been searched for yet.</span>
<span class="hl com">         * &gt;0 -&gt; decoder found</span>
<span class="hl com">         * &lt;0 -&gt; decoder with codec_id == -found_decoder has not been found</span>
<span class="hl com">         */</span>
        <span class="hl kwb">int</span> found_decoder<span class="hl opt">;</span>

        <span class="hl kwb">int64_t</span> last_duration<span class="hl opt">;</span>

        <span class="hl com">/**</span>
<span class="hl com">         * Those are used for average framerate estimation.</span>
<span class="hl com">         */</span>
        <span class="hl kwb">int64_t</span> fps_first_dts<span class="hl opt">;</span>
        <span class="hl kwb">int</span>     fps_first_dts_idx<span class="hl opt">;</span>
        <span class="hl kwb">int64_t</span> fps_last_dts<span class="hl opt">;</span>
        <span class="hl kwb">int</span>     fps_last_dts_idx<span class="hl opt">;</span>

    <span class="hl opt">} *</span>info<span class="hl opt">;</span>

    <span class="hl kwb">int</span> pts_wrap_bits<span class="hl opt">;</span> <span class="hl com">/**&lt; number of bits in pts (used for wrapping control) */</span>

    <span class="hl slc">// Timestamp generation support:</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Timestamp corresponding to the last dts sync point.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Initialized when AVCodecParserContext.dts_sync_point &gt;= 0 and</span>
<span class="hl com">     * a DTS is received from the underlying container. Otherwise set to</span>
<span class="hl com">     * AV_NOPTS_VALUE by default.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> first_dts<span class="hl opt">;</span>
    <span class="hl kwb">int64_t</span> cur_dts<span class="hl opt">;</span>
    <span class="hl kwb">int64_t</span> last_IP_pts<span class="hl opt">;</span>
    <span class="hl kwb">int</span> last_IP_duration<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of packets to buffer for codec probing</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> probe_packets<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of frames that have been demuxed during avformat_find_stream_info()</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> codec_info_nb_frames<span class="hl opt">;</span>

    <span class="hl com">/* av_read_frame() support */</span>
    <span class="hl kwb">enum</span> AVStreamParseType need_parsing<span class="hl opt">;</span>
    <span class="hl kwb">struct</span> AVCodecParserContext <span class="hl opt">*</span>parser<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * last packet in packet_buffer for this stream when muxing.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">struct</span> AVPacketList <span class="hl opt">*</span>last_in_packet_buffer<span class="hl opt">;</span>
    AVProbeData probe_data<span class="hl opt">;</span>
<span class="hl ppc">#define MAX_REORDER_DELAY 16</span>
    <span class="hl kwb">int64_t</span> pts_buffer<span class="hl opt">[</span>MAX_REORDER_DELAY<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">];</span>

    AVIndexEntry <span class="hl opt">*</span>index_entries<span class="hl opt">;</span> <span class="hl com">/**&lt; Only used if the format does not</span>
<span class="hl com">                                    support seeking natively. */</span>
    <span class="hl kwb">int</span> nb_index_entries<span class="hl opt">;</span>
    <span class="hl kwb">unsigned int</span> index_entries_allocated_size<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Real base framerate of the stream.</span>
<span class="hl com">     * This is the lowest framerate with which all timestamps can be</span>
<span class="hl com">     * represented accurately (it is the least common multiple of all</span>
<span class="hl com">     * framerates in the stream). Note, this value is just a guess!</span>
<span class="hl com">     * For example, if the time base is 1/90000 and all frames have either</span>
<span class="hl com">     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Code outside avformat should access this field using:</span>
<span class="hl com">     * av_stream_get/set_r_frame_rate(stream)</span>
<span class="hl com">     */</span>
    AVRational r_frame_rate<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Stream Identifier</span>
<span class="hl com">     * This is the MPEG-TS stream identifier +1</span>
<span class="hl com">     * 0 means unknown</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> stream_identifier<span class="hl opt">;</span>

    <span class="hl kwb">int64_t</span> interleaver_chunk_size<span class="hl opt">;</span>
    <span class="hl kwb">int64_t</span> interleaver_chunk_duration<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * stream probing state</span>
<span class="hl com">     * -1   -&gt; probing finished</span>
<span class="hl com">     *  0   -&gt; no probing requested</span>
<span class="hl com">     * rest -&gt; perform probing with request_probe being the minimum score to accept.</span>
<span class="hl com">     * NOT PART OF PUBLIC API</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> request_probe<span class="hl opt">;</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Indicates that everything up to the next keyframe</span>
<span class="hl com">     * should be discarded.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> skip_to_keyframe<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of samples to skip at the start of the frame decoded from the next packet.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> skip_samples<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * If not 0, the number of samples that should be skipped from the start of</span>
<span class="hl com">     * the stream (the samples are removed from packets with pts==0, which also</span>
<span class="hl com">     * assumes negative timestamps do not happen).</span>
<span class="hl com">     * Intended for use with formats such as mp3 with ad-hoc gapless audio</span>
<span class="hl com">     * support.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> start_skip_samples<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * If not 0, the first audio sample that should be discarded from the stream.</span>
<span class="hl com">     * This is broken by design (needs global sample count), but can&apos;t be</span>
<span class="hl com">     * avoided for broken by design formats such as mp3 with ad-hoc gapless</span>
<span class="hl com">     * audio support.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> first_discard_sample<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The sample after last sample that is intended to be discarded after</span>
<span class="hl com">     * first_discard_sample. Works on frame boundaries only. Used to prevent</span>
<span class="hl com">     * early EOF if the gapless info is broken (considered concatenated mp3s).</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> last_discard_sample<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of internally decoded frames, used internally in libavformat, do not access</span>
<span class="hl com">     * its lifetime differs from info which is why it is not in that structure.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> nb_decoded_frames<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Timestamp offset added to timestamps before muxing</span>
<span class="hl com">     * NOT PART OF PUBLIC API</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> mux_ts_offset<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Internal data to check for wrapping of the time stamp</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> pts_wrap_reference<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Options for behavior, when a wrap is detected.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Defined by AV_PTS_WRAP_ values.</span>
<span class="hl com">     *</span>
<span class="hl com">     * If correction is enabled, there are two possibilities:</span>
<span class="hl com">     * If the first time stamp is near the wrap point, the wrap offset</span>
<span class="hl com">     * will be subtracted, which will create negative time stamps.</span>
<span class="hl com">     * Otherwise the offset will be added.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> pts_wrap_behavior<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Internal data to prevent doing update_initial_durations() twice</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> update_initial_durations_done<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Internal data to generate dts from pts</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> pts_reorder_error<span class="hl opt">[</span>MAX_REORDER_DELAY<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">];</span>
    <span class="hl kwb">uint8_t</span> pts_reorder_error_count<span class="hl opt">[</span>MAX_REORDER_DELAY<span class="hl opt">+</span><span class="hl num">1</span><span class="hl opt">];</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Internal data to analyze DTS and detect faulty mpeg streams</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> last_dts_for_order_check<span class="hl opt">;</span>
    <span class="hl kwb">uint8_t</span> dts_ordered<span class="hl opt">;</span>
    <span class="hl kwb">uint8_t</span> dts_misordered<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Internal data to inject global side data</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> inject_global_side_data<span class="hl opt">;</span>

    <span class="hl com">/*****************************************************************</span>
<span class="hl com">     * All fields above this line are not part of the public API.</span>
<span class="hl com">     * Fields below are part of the public API and ABI again.</span>
<span class="hl com">     *****************************************************************</span>
<span class="hl com">     */</span>

    <span class="hl com">/**</span>
<span class="hl com">     * String containing paris of key and values describing recommended encoder configuration.</span>
<span class="hl com">     * Paris are separated by &apos;,&apos;.</span>
<span class="hl com">     * Keys are separated from values by &apos;=&apos;.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> <span class="hl opt">*</span>recommended_encoder_configuration<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * display aspect ratio (0 if unknown)</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally</span>
<span class="hl com">     */</span>
    AVRational display_aspect_ratio<span class="hl opt">;</span>

    <span class="hl kwb">struct</span> FFFrac <span class="hl opt">*</span>priv_pts<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * An opaque field for libavformat internal usage.</span>
<span class="hl com">     * Must not be accessed in any way by callers.</span>
<span class="hl com">     */</span>
    AVStreamInternal <span class="hl opt">*</span>internal<span class="hl opt">;</span>

    <span class="hl com">/*</span>
<span class="hl com">     * Codec parameters associated with this stream. Allocated and freed by</span>
<span class="hl com">     * libavformat in avformat_new_stream() and avformat_free_context()</span>
<span class="hl com">     * respectively.</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: filled by libavformat on stream creation or in</span>
<span class="hl com">     *             avformat_find_stream_info()</span>
<span class="hl com">     * - muxing: filled by the caller before avformat_write_header()</span>
<span class="hl com">     */</span>
    AVCodecParameters <span class="hl opt">*</span>codecpar<span class="hl opt">;</span>
<span class="hl opt">}</span> AVStream<span class="hl opt">;</span>

AVRational <span class="hl kwd">av_stream_get_r_frame_rate</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>       <span class="hl kwd">av_stream_set_r_frame_rate</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>s<span class="hl opt">,</span> AVRational r<span class="hl opt">);</span>
<span class="hl kwb">struct</span> AVCodecParserContext <span class="hl opt">*</span><span class="hl kwd">av_stream_get_parser</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">char</span><span class="hl opt">*</span> <span class="hl kwd">av_stream_get_recommended_encoder_configuration</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>  <span class="hl kwd">av_stream_set_recommended_encoder_configuration</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">*</span>configuration<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Returns the pts of the last muxed packet + its duration</span>
<span class="hl com"> *</span>
<span class="hl com"> * the retuned value is undefined when used with a demuxer.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int64_t</span>    <span class="hl kwd">av_stream_get_end_pts</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>st<span class="hl opt">);</span>

<span class="hl ppc">#define AV_PROGRAM_RUNNING 1</span>

<span class="hl com">/**</span>
<span class="hl com"> * New fields can be added to the end with minor version bumps.</span>
<span class="hl com"> * Removal, reordering and changes to existing fields require a major</span>
<span class="hl com"> * version bump.</span>
<span class="hl com"> * sizeof(AVProgram) must not be used outside libav*.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVProgram <span class="hl opt">{</span>
    <span class="hl kwb">int</span>            id<span class="hl opt">;</span>
    <span class="hl kwb">int</span>            flags<span class="hl opt">;</span>
    <span class="hl kwb">enum</span> AVDiscard discard<span class="hl opt">;</span>        <span class="hl slc">///&lt; selects which program to discard and which to feed to the caller</span>
    <span class="hl kwb">unsigned int</span>   <span class="hl opt">*</span>stream_index<span class="hl opt">;</span>
    <span class="hl kwb">unsigned int</span>   nb_stream_indexes<span class="hl opt">;</span>
    AVDictionary <span class="hl opt">*</span>metadata<span class="hl opt">;</span>

    <span class="hl kwb">int</span> program_num<span class="hl opt">;</span>
    <span class="hl kwb">int</span> pmt_pid<span class="hl opt">;</span>
    <span class="hl kwb">int</span> pcr_pid<span class="hl opt">;</span>

    <span class="hl com">/*****************************************************************</span>
<span class="hl com">     * All fields below this line are not part of the public API. They</span>
<span class="hl com">     * may not be used outside of libavformat and can be changed and</span>
<span class="hl com">     * removed at will.</span>
<span class="hl com">     * New public fields should be added right above.</span>
<span class="hl com">     *****************************************************************</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> start_time<span class="hl opt">;</span>
    <span class="hl kwb">int64_t</span> end_time<span class="hl opt">;</span>

    <span class="hl kwb">int64_t</span> pts_wrap_reference<span class="hl opt">;</span>    <span class="hl slc">///&lt; reference dts for wrap detection</span>
    <span class="hl kwb">int</span> pts_wrap_behavior<span class="hl opt">;</span>         <span class="hl slc">///&lt; behavior on wrap detection</span>
<span class="hl opt">}</span> AVProgram<span class="hl opt">;</span>

<span class="hl ppc">#define AVFMTCTX_NOHEADER      0x0001</span> <span class="hl com">/**&lt; signal that no header is present</span>
<span class="hl com">                                         (streams are added dynamically) */</span><span class="hl ppc"></span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVChapter <span class="hl opt">{</span>
    <span class="hl kwb">int</span> id<span class="hl opt">;</span>                 <span class="hl slc">///&lt; unique ID to identify the chapter</span>
    AVRational time_base<span class="hl opt">;</span>   <span class="hl slc">///&lt; time base in which the start/end timestamps are specified</span>
    <span class="hl kwb">int64_t</span> start<span class="hl opt">,</span> end<span class="hl opt">;</span>     <span class="hl slc">///&lt; chapter start/end time in time_base units</span>
    AVDictionary <span class="hl opt">*</span>metadata<span class="hl opt">;</span>
<span class="hl opt">}</span> AVChapter<span class="hl opt">;</span>


<span class="hl com">/**</span>
<span class="hl com"> * Callback used by devices to communicate with application.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">int</span> <span class="hl opt">(*</span>av_format_control_message<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> type<span class="hl opt">,</span>
                                         <span class="hl kwb">void</span> <span class="hl opt">*</span>data<span class="hl opt">,</span> <span class="hl kwb">size_t</span> data_size<span class="hl opt">);</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">int</span> <span class="hl opt">(*</span>AVOpenCallback<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVIOContext <span class="hl opt">**</span>pb<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">,</span>
                              <span class="hl kwb">const</span> AVIOInterruptCB <span class="hl opt">*</span>int_cb<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * The duration of a video can be estimated through various ways, and this enum can be used</span>
<span class="hl com"> * to know how the duration was estimated.</span>
<span class="hl com"> */</span>
<span class="hl kwb">enum</span> AVDurationEstimationMethod <span class="hl opt">{</span>
    AVFMT_DURATION_FROM_PTS<span class="hl opt">,</span>    <span class="hl slc">///&lt; Duration accurately estimated from PTSes</span>
    AVFMT_DURATION_FROM_STREAM<span class="hl opt">,</span> <span class="hl slc">///&lt; Duration estimated from a stream with a known duration</span>
    AVFMT_DURATION_FROM_BITRATE <span class="hl slc">///&lt; Duration estimated from bitrate (less accurate)</span>
<span class="hl opt">};</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVFormatInternal AVFormatInternal<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * Format I/O context.</span>
<span class="hl com"> * New fields can be added to the end with minor version bumps.</span>
<span class="hl com"> * Removal, reordering and changes to existing fields require a major</span>
<span class="hl com"> * version bump.</span>
<span class="hl com"> * sizeof(AVFormatContext) must not be used outside libav*, use</span>
<span class="hl com"> * avformat_alloc_context() to create an AVFormatContext.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Fields can be accessed through AVOptions (av_opt*),</span>
<span class="hl com"> * the name string used matches the associated command line parameter name and</span>
<span class="hl com"> * can be found in libavformat/options_table.h.</span>
<span class="hl com"> * The AVOption/command line parameter names differ in some cases from the C</span>
<span class="hl com"> * structure field names for historic reasons or brevity.</span>
<span class="hl com"> */</span>
<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">{</span>
    <span class="hl com">/**</span>
<span class="hl com">     * A class for logging and &#64;ref avoptions. Set by avformat_alloc_context().</span>
<span class="hl com">     * Exports (de)muxer private options if they exist.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">const</span> AVClass <span class="hl opt">*</span>av_class<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The input container format.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Demuxing only, set by avformat_open_input().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">struct</span> AVInputFormat <span class="hl opt">*</span>iformat<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The output container format.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Muxing only, must be set by the caller before avformat_write_header().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">struct</span> AVOutputFormat <span class="hl opt">*</span>oformat<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Format private data. This is an AVOptions-enabled struct</span>
<span class="hl com">     * if and only if iformat/oformat.priv_class is not NULL.</span>
<span class="hl com">     *</span>
<span class="hl com">     * - muxing: set by avformat_write_header()</span>
<span class="hl com">     * - demuxing: set by avformat_open_input()</span>
<span class="hl com">     */</span>
    <span class="hl kwb">void</span> <span class="hl opt">*</span>priv_data<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * I/O context.</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: either set by the user before avformat_open_input() (then</span>
<span class="hl com">     *             the user must close it manually) or set by avformat_open_input().</span>
<span class="hl com">     * - muxing: set by the user before avformat_write_header(). The caller must</span>
<span class="hl com">     *           take care of closing / freeing the IO context.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Do NOT set this field if AVFMT_NOFILE flag is set in</span>
<span class="hl com">     * iformat/oformat.flags. In such a case, the (de)muxer will handle</span>
<span class="hl com">     * I/O in some other way and this field will be NULL.</span>
<span class="hl com">     */</span>
    AVIOContext <span class="hl opt">*</span>pb<span class="hl opt">;</span>

    <span class="hl com">/* stream info */</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Flags signalling stream properties. A combination of AVFMTCTX_*.</span>
<span class="hl com">     * Set by libavformat.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> ctx_flags<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of elements in AVFormatContext.streams.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Set by avformat_new_stream(), must not be modified by any other code.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">unsigned int</span> nb_streams<span class="hl opt">;</span>
    <span class="hl com">/**</span>
<span class="hl com">     * A list of all streams in the file. New streams are created with</span>
<span class="hl com">     * avformat_new_stream().</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: streams are created by libavformat in avformat_open_input().</span>
<span class="hl com">     *             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also</span>
<span class="hl com">     *             appear in av_read_frame().</span>
<span class="hl com">     * - muxing: streams are created by the user before avformat_write_header().</span>
<span class="hl com">     *</span>
<span class="hl com">     * Freed by libavformat in avformat_free_context().</span>
<span class="hl com">     */</span>
    AVStream <span class="hl opt">**</span>streams<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * input or output filename</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: set by avformat_open_input()</span>
<span class="hl com">     * - muxing: may be set by the caller before avformat_write_header()</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> filename<span class="hl opt">[</span><span class="hl num">1024</span><span class="hl opt">];</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Position of the first frame of the component, in</span>
<span class="hl com">     * AV_TIME_BASE fractional seconds. NEVER set this value directly:</span>
<span class="hl com">     * It is deduced from the AVStream values.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Demuxing only, set by libavformat.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> start_time<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Duration of the stream, in AV_TIME_BASE fractional</span>
<span class="hl com">     * seconds. Only set this value if you know none of the individual stream</span>
<span class="hl com">     * durations and also do not set any of them. This is deduced from the</span>
<span class="hl com">     * AVStream values if not set.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Demuxing only, set by libavformat.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> duration<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Total stream bitrate in bit/s, 0 if not</span>
<span class="hl com">     * available. Never set it directly if the file_size and the</span>
<span class="hl com">     * duration are known as FFmpeg can compute it automatically.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> bit_rate<span class="hl opt">;</span>

    <span class="hl kwb">unsigned int</span> packet_size<span class="hl opt">;</span>
    <span class="hl kwb">int</span> max_delay<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.</span>
<span class="hl com">     * Set by the user before avformat_open_input() / avformat_write_header().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> flags<span class="hl opt">;</span>
<span class="hl ppc">#define AVFMT_FLAG_GENPTS       0x0001</span> <span class="hl slc">///&lt; Generate missing pts even if it requires parsing future frames.</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_IGNIDX       0x0002</span> <span class="hl slc">///&lt; Ignore index.</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_NONBLOCK     0x0004</span> <span class="hl slc">///&lt; Do not block when reading packets from input.</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_IGNDTS       0x0008</span> <span class="hl slc">///&lt; Ignore DTS on frames that contain both DTS &amp; PTS</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_NOFILLIN     0x0010</span> <span class="hl slc">///&lt; Do not infer any values from other values, just return what is stored in the container</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_NOPARSE      0x0020</span> <span class="hl slc">///&lt; Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -&gt; no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_NOBUFFER     0x0040</span> <span class="hl slc">///&lt; Do not buffer frames when possible</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_CUSTOM_IO    0x0080</span> <span class="hl slc">///&lt; The caller has supplied a custom AVIOContext, don&apos;t avio_close() it.</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_DISCARD_CORRUPT  0x0100</span> <span class="hl slc">///&lt; Discard frames marked corrupted</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_FLUSH_PACKETS    0x0200</span> <span class="hl slc">///&lt; Flush the AVIOContext every packet.</span>
<span class="hl ppc"></span><span class="hl com">/**</span>
<span class="hl com"> * When muxing, try to avoid writing any random/volatile data to the output.</span>
<span class="hl com"> * This includes any random IDs, real-time timestamps/dates, muxer version, etc.</span>
<span class="hl com"> *</span>
<span class="hl com"> * This flag is mainly intended for testing.</span>
<span class="hl com"> */</span>
<span class="hl ppc">#define AVFMT_FLAG_BITEXACT         0x0400</span>
<span class="hl ppc">#define AVFMT_FLAG_MP4A_LATM    0x8000</span> <span class="hl slc">///&lt; Enable RTP MP4A-LATM payload</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_SORT_DTS    0x10000</span> <span class="hl slc">///&lt; try to interleave outputted packets by dts (using this flag can slow demuxing down)</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_PRIV_OPT    0x20000</span> <span class="hl slc">///&lt; Enable use of private options by delaying codec open (this could be made default once all code is converted)</span>
<span class="hl ppc"></span><span class="hl ppc">#if FF_API_LAVF_KEEPSIDE_FLAG</span>
<span class="hl ppc">#define AVFMT_FLAG_KEEP_SIDE_DATA 0x40000</span> <span class="hl slc">///&lt; Don&apos;t merge side data but keep it separate. Deprecated, will be the default.</span>
<span class="hl ppc"></span><span class="hl ppc">#endif</span>
<span class="hl ppc">#define AVFMT_FLAG_FAST_SEEK   0x80000</span> <span class="hl slc">///&lt; Enable fast, but inaccurate seeks for some formats</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_SHORTEST   0x100000</span> <span class="hl slc">///&lt; Stop muxing when the shortest stream stops.</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_FLAG_AUTO_BSF   0x200000</span> <span class="hl slc">///&lt; Wait for packet data before writing a header, and add bitstream filters as requested by the muxer</span>
<span class="hl ppc"></span>
    <span class="hl com">/**</span>
<span class="hl com">     * Maximum size of the data read from input for determining</span>
<span class="hl com">     * the input container format.</span>
<span class="hl com">     * Demuxing only, set by the caller before avformat_open_input().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> probesize<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Maximum duration (in AV_TIME_BASE units) of the data read</span>
<span class="hl com">     * from input in avformat_find_stream_info().</span>
<span class="hl com">     * Demuxing only, set by the caller before avformat_find_stream_info().</span>
<span class="hl com">     * Can be set to 0 to let avformat choose using a heuristic.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> max_analyze_duration<span class="hl opt">;</span>

    <span class="hl kwb">const uint8_t</span> <span class="hl opt">*</span>key<span class="hl opt">;</span>
    <span class="hl kwb">int</span> keylen<span class="hl opt">;</span>

    <span class="hl kwb">unsigned int</span> nb_programs<span class="hl opt">;</span>
    AVProgram <span class="hl opt">**</span>programs<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced video codec_id.</span>
<span class="hl com">     * Demuxing: Set by user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">enum</span> AVCodecID video_codec_id<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced audio codec_id.</span>
<span class="hl com">     * Demuxing: Set by user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">enum</span> AVCodecID audio_codec_id<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced subtitle codec_id.</span>
<span class="hl com">     * Demuxing: Set by user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">enum</span> AVCodecID subtitle_codec_id<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Maximum amount of memory in bytes to use for the index of each stream.</span>
<span class="hl com">     * If the index exceeds this size, entries will be discarded as</span>
<span class="hl com">     * needed to maintain a smaller size. This can lead to slower or less</span>
<span class="hl com">     * accurate seeking (depends on demuxer).</span>
<span class="hl com">     * Demuxers for which a full in-memory index is mandatory will ignore</span>
<span class="hl com">     * this.</span>
<span class="hl com">     * - muxing: unused</span>
<span class="hl com">     * - demuxing: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">unsigned int</span> max_index_size<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Maximum amount of memory in bytes to use for buffering frames</span>
<span class="hl com">     * obtained from realtime capture devices.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">unsigned int</span> max_picture_buffer<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of chapters in AVChapter array.</span>
<span class="hl com">     * When muxing, chapters are normally written in the file header,</span>
<span class="hl com">     * so nb_chapters should normally be initialized before write_header</span>
<span class="hl com">     * is called. Some muxers (e.g. mov and mkv) can also write chapters</span>
<span class="hl com">     * in the trailer.  To write chapters in the trailer, nb_chapters</span>
<span class="hl com">     * must be zero when write_header is called and non-zero when</span>
<span class="hl com">     * write_trailer is called.</span>
<span class="hl com">     * - muxing: set by user</span>
<span class="hl com">     * - demuxing: set by libavformat</span>
<span class="hl com">     */</span>
    <span class="hl kwb">unsigned int</span> nb_chapters<span class="hl opt">;</span>
    AVChapter <span class="hl opt">**</span>chapters<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Metadata that applies to the whole file.</span>
<span class="hl com">     *</span>
<span class="hl com">     * - demuxing: set by libavformat in avformat_open_input()</span>
<span class="hl com">     * - muxing: may be set by the caller before avformat_write_header()</span>
<span class="hl com">     *</span>
<span class="hl com">     * Freed by libavformat in avformat_free_context().</span>
<span class="hl com">     */</span>
    AVDictionary <span class="hl opt">*</span>metadata<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Start time of the stream in real world time, in microseconds</span>
<span class="hl com">     * since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the</span>
<span class="hl com">     * stream was captured at this real world time.</span>
<span class="hl com">     * - muxing: Set by the caller before avformat_write_header(). If set to</span>
<span class="hl com">     *           either 0 or AV_NOPTS_VALUE, then the current wall-time will</span>
<span class="hl com">     *           be used.</span>
<span class="hl com">     * - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that</span>
<span class="hl com">     *             the value may become known after some number of frames</span>
<span class="hl com">     *             have been received.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> start_time_realtime<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The number of frames used for determining the framerate in</span>
<span class="hl com">     * avformat_find_stream_info().</span>
<span class="hl com">     * Demuxing only, set by the caller before avformat_find_stream_info().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> fps_probe_size<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Error recognition; higher values will detect more errors but may</span>
<span class="hl com">     * misdetect some more or less valid parts as errors.</span>
<span class="hl com">     * Demuxing only, set by the caller before avformat_open_input().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> error_recognition<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Custom interrupt callbacks for the I/O layer.</span>
<span class="hl com">     *</span>
<span class="hl com">     * demuxing: set by the user before avformat_open_input().</span>
<span class="hl com">     * muxing: set by the user before avformat_write_header()</span>
<span class="hl com">     * (mainly useful for AVFMT_NOFILE formats). The callback</span>
<span class="hl com">     * should also be passed to avio_open2() if it&apos;s used to</span>
<span class="hl com">     * open the file.</span>
<span class="hl com">     */</span>
    AVIOInterruptCB interrupt_callback<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Flags to enable debugging.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> debug<span class="hl opt">;</span>
<span class="hl ppc">#define FF_FDEBUG_TS        0x0001</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Maximum buffering duration for interleaving.</span>
<span class="hl com">     *</span>
<span class="hl com">     * To ensure all the streams are interleaved correctly,</span>
<span class="hl com">     * av_interleaved_write_frame() will wait until it has at least one packet</span>
<span class="hl com">     * for each stream before actually writing any packets to the output file.</span>
<span class="hl com">     * When some streams are &quot;sparse&quot; (i.e. there are large gaps between</span>
<span class="hl com">     * successive packets), this can result in excessive buffering.</span>
<span class="hl com">     *</span>
<span class="hl com">     * This field specifies the maximum difference between the timestamps of the</span>
<span class="hl com">     * first and the last packet in the muxing queue, above which libavformat</span>
<span class="hl com">     * will output a packet regardless of whether it has queued a packet for all</span>
<span class="hl com">     * the streams.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Muxing only, set by the caller before avformat_write_header().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> max_interleave_delta<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Allow non-standard and experimental extension</span>
<span class="hl com">     * &#64;see AVCodecContext.strict_std_compliance</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> strict_std_compliance<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Flags for the user to detect events happening on the file. Flags must</span>
<span class="hl com">     * be cleared by the user once the event has been handled.</span>
<span class="hl com">     * A combination of AVFMT_EVENT_FLAG_*.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> event_flags<span class="hl opt">;</span>
<span class="hl ppc">#define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001</span> <span class="hl slc">///&lt; The call resulted in updated metadata.</span>
<span class="hl ppc"></span>
    <span class="hl com">/**</span>
<span class="hl com">     * Maximum number of packets to read while waiting for the first timestamp.</span>
<span class="hl com">     * Decoding only.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> max_ts_probe<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Avoid negative timestamps during muxing.</span>
<span class="hl com">     * Any value of the AVFMT_AVOID_NEG_TS_* constants.</span>
<span class="hl com">     * Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)</span>
<span class="hl com">     * - muxing: Set by user</span>
<span class="hl com">     * - demuxing: unused</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> avoid_negative_ts<span class="hl opt">;</span>
<span class="hl ppc">#define AVFMT_AVOID_NEG_TS_AUTO             -1</span> <span class="hl slc">///&lt; Enabled when required by target format</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1</span> <span class="hl slc">///&lt; Shift timestamps so they are non negative</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVFMT_AVOID_NEG_TS_MAKE_ZERO         2</span> <span class="hl slc">///&lt; Shift timestamps so that they start at 0</span>
<span class="hl ppc"></span>
    <span class="hl com">/**</span>
<span class="hl com">     * Transport stream id.</span>
<span class="hl com">     * This will be moved into demuxer private options. Thus no API/ABI compatibility</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> ts_id<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Audio preload in microseconds.</span>
<span class="hl com">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span>
<span class="hl com">     * - encoding: Set by user</span>
<span class="hl com">     * - decoding: unused</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> audio_preload<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Max chunk time in microseconds.</span>
<span class="hl com">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span>
<span class="hl com">     * - encoding: Set by user</span>
<span class="hl com">     * - decoding: unused</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> max_chunk_duration<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Max chunk size in bytes</span>
<span class="hl com">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span>
<span class="hl com">     * - encoding: Set by user</span>
<span class="hl com">     * - decoding: unused</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> max_chunk_size<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * forces the use of wallclock timestamps as pts/dts of packets</span>
<span class="hl com">     * This has undefined results in the presence of B frames.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> use_wallclock_as_timestamps<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * avio flags, used to force AVIO_FLAG_DIRECT.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> avio_flags<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The duration field can be estimated through various ways, and this field can be used</span>
<span class="hl com">     * to know how the duration was estimated.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Read by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">enum</span> AVDurationEstimationMethod duration_estimation_method<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Skip initial bytes when opening stream</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> skip_initial_bytes<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Correct single timestamp overflows</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">unsigned int</span> correct_ts_overflow<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Force seeking to any (also non key) frames.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: Set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> seek2any<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Flush the I/O context after each packet.</span>
<span class="hl com">     * - encoding: Set by user</span>
<span class="hl com">     * - decoding: unused</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> flush_packets<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * format probing score.</span>
<span class="hl com">     * The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes</span>
<span class="hl com">     * the format.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by avformat, read by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> probe_score<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * number of bytes to read maximally to identify format.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> format_probesize<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * &apos;,&apos; separated list of allowed decoders.</span>
<span class="hl com">     * If NULL then all are allowed</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> <span class="hl opt">*</span>codec_whitelist<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * &apos;,&apos; separated list of allowed demuxers.</span>
<span class="hl com">     * If NULL then all are allowed</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> <span class="hl opt">*</span>format_whitelist<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * An opaque field for libavformat internal usage.</span>
<span class="hl com">     * Must not be accessed in any way by callers.</span>
<span class="hl com">     */</span>
    AVFormatInternal <span class="hl opt">*</span>internal<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * IO repositioned flag.</span>
<span class="hl com">     * This is set by avformat when the underlaying IO context read pointer</span>
<span class="hl com">     * is repositioned, for example when doing byte based seeking.</span>
<span class="hl com">     * Demuxers can use the flag to detect such changes.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> io_repositioned<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced video codec.</span>
<span class="hl com">     * This allows forcing a specific decoder, even when there are multiple with</span>
<span class="hl com">     * the same codec_id.</span>
<span class="hl com">     * Demuxing: Set by user</span>
<span class="hl com">     */</span>
    AVCodec <span class="hl opt">*</span>video_codec<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced audio codec.</span>
<span class="hl com">     * This allows forcing a specific decoder, even when there are multiple with</span>
<span class="hl com">     * the same codec_id.</span>
<span class="hl com">     * Demuxing: Set by user</span>
<span class="hl com">     */</span>
    AVCodec <span class="hl opt">*</span>audio_codec<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced subtitle codec.</span>
<span class="hl com">     * This allows forcing a specific decoder, even when there are multiple with</span>
<span class="hl com">     * the same codec_id.</span>
<span class="hl com">     * Demuxing: Set by user</span>
<span class="hl com">     */</span>
    AVCodec <span class="hl opt">*</span>subtitle_codec<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced data codec.</span>
<span class="hl com">     * This allows forcing a specific decoder, even when there are multiple with</span>
<span class="hl com">     * the same codec_id.</span>
<span class="hl com">     * Demuxing: Set by user</span>
<span class="hl com">     */</span>
    AVCodec <span class="hl opt">*</span>data_codec<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Number of bytes to be written as padding in a metadata header.</span>
<span class="hl com">     * Demuxing: Unused.</span>
<span class="hl com">     * Muxing: Set by user via av_format_set_metadata_header_padding.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> metadata_header_padding<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * User data.</span>
<span class="hl com">     * This is a place for some private data of the user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">void</span> <span class="hl opt">*</span>opaque<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Callback used by devices to communicate with application.</span>
<span class="hl com">     */</span>
    av_format_control_message control_message_cb<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Output timestamp offset, in microseconds.</span>
<span class="hl com">     * Muxing: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int64_t</span> output_ts_offset<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * dump format separator.</span>
<span class="hl com">     * can be &quot;, &quot; or &quot;\n      &quot; or anything else</span>
<span class="hl com">     * - muxing: Set by user.</span>
<span class="hl com">     * - demuxing: Set by user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>dump_separator<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * Forced Data codec_id.</span>
<span class="hl com">     * Demuxing: Set by user.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">enum</span> AVCodecID data_codec_id<span class="hl opt">;</span>

<span class="hl ppc">#if FF_API_OLD_OPEN_CALLBACKS</span>
    <span class="hl com">/**</span>
<span class="hl com">     * Called to open further IO contexts when needed for demuxing.</span>
<span class="hl com">     *</span>
<span class="hl com">     * This can be set by the user application to perform security checks on</span>
<span class="hl com">     * the URLs before opening them.</span>
<span class="hl com">     * The function should behave like avio_open2(), AVFormatContext is provided</span>
<span class="hl com">     * as contextual information and to reach AVFormatContext.opaque.</span>
<span class="hl com">     *</span>
<span class="hl com">     * If NULL then some simple checks are used together with avio_open2().</span>
<span class="hl com">     *</span>
<span class="hl com">     * Must not be accessed directly from outside avformat.</span>
<span class="hl com">     * &#64;See av_format_set_open_cb()</span>
<span class="hl com">     *</span>
<span class="hl com">     * Demuxing: Set by user.</span>
<span class="hl com">     *</span>
<span class="hl com">     * &#64;deprecated Use io_open and io_close.</span>
<span class="hl com">     */</span>
    attribute_deprecated
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>open_cb<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVIOContext <span class="hl opt">**</span>p<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">,</span> <span class="hl kwb">const</span> AVIOInterruptCB <span class="hl opt">*</span>int_cb<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>
<span class="hl ppc">#endif</span>

    <span class="hl com">/**</span>
<span class="hl com">     * &apos;,&apos; separated list of allowed protocols.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> <span class="hl opt">*</span>protocol_whitelist<span class="hl opt">;</span>

    <span class="hl com">/*</span>
<span class="hl com">     * A callback for opening new IO streams.</span>
<span class="hl com">     *</span>
<span class="hl com">     * Whenever a muxer or a demuxer needs to open an IO stream (typically from</span>
<span class="hl com">     * avformat_open_input() for demuxers, but for certain formats can happen at</span>
<span class="hl com">     * other times as well), it will call this callback to obtain an IO context.</span>
<span class="hl com">     *</span>
<span class="hl com">     * &#64;param s the format context</span>
<span class="hl com">     * &#64;param pb on success, the newly opened IO context should be returned here</span>
<span class="hl com">     * &#64;param url the url to open</span>
<span class="hl com">     * &#64;param flags a combination of AVIO_FLAG_*</span>
<span class="hl com">     * &#64;param options a dictionary of additional options, with the same</span>
<span class="hl com">     *                semantics as in avio_open2()</span>
<span class="hl com">     * &#64;return 0 on success, a negative AVERROR code on failure</span>
<span class="hl com">     *</span>
<span class="hl com">     * &#64;note Certain muxers and demuxers do nesting, i.e. they open one or more</span>
<span class="hl com">     * additional internal format contexts. Thus the AVFormatContext pointer</span>
<span class="hl com">     * passed to this callback may be different from the one facing the caller.</span>
<span class="hl com">     * It will, however, have the same &apos;opaque&apos; field.</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> <span class="hl opt">(*</span>io_open<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVIOContext <span class="hl opt">**</span>pb<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span>
                   <span class="hl kwb">int</span> flags<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * A callback for closing the streams opened with AVFormatContext.io_open().</span>
<span class="hl com">     */</span>
    <span class="hl kwb">void</span> <span class="hl opt">(*</span>io_close<span class="hl opt">)(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVIOContext <span class="hl opt">*</span>pb<span class="hl opt">);</span>

    <span class="hl com">/**</span>
<span class="hl com">     * &apos;,&apos; separated list of disallowed protocols.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">char</span> <span class="hl opt">*</span>protocol_blacklist<span class="hl opt">;</span>

    <span class="hl com">/**</span>
<span class="hl com">     * The maximum number of streams.</span>
<span class="hl com">     * - encoding: unused</span>
<span class="hl com">     * - decoding: set by user</span>
<span class="hl com">     */</span>
    <span class="hl kwb">int</span> max_streams<span class="hl opt">;</span>
<span class="hl opt">}</span> AVFormatContext<span class="hl opt">;</span>

<span class="hl com">/**</span>
<span class="hl com"> * Accessors for some AVFormatContext fields. These used to be provided for ABI</span>
<span class="hl com"> * compatibility, and do not need to be used anymore.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_format_get_probe_score</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
AVCodec <span class="hl opt">*</span> <span class="hl kwd">av_format_get_video_codec</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_video_codec</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVCodec <span class="hl opt">*</span>c<span class="hl opt">);</span>
AVCodec <span class="hl opt">*</span> <span class="hl kwd">av_format_get_audio_codec</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_audio_codec</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVCodec <span class="hl opt">*</span>c<span class="hl opt">);</span>
AVCodec <span class="hl opt">*</span> <span class="hl kwd">av_format_get_subtitle_codec</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_subtitle_codec</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVCodec <span class="hl opt">*</span>c<span class="hl opt">);</span>
AVCodec <span class="hl opt">*</span> <span class="hl kwd">av_format_get_data_codec</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_data_codec</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVCodec <span class="hl opt">*</span>c<span class="hl opt">);</span>
<span class="hl kwb">int</span>       <span class="hl kwd">av_format_get_metadata_header_padding</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_metadata_header_padding</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> c<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl opt">*</span>    <span class="hl kwd">av_format_get_opaque</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_opaque</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">void</span> <span class="hl opt">*</span>opaque<span class="hl opt">);</span>
av_format_control_message <span class="hl kwd">av_format_get_control_message_cb</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
<span class="hl kwb">void</span>      <span class="hl kwd">av_format_set_control_message_cb</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> av_format_control_message callback<span class="hl opt">);</span>
<span class="hl ppc">#if FF_API_OLD_OPEN_CALLBACKS</span>
attribute_deprecated AVOpenCallback <span class="hl kwd">av_format_get_open_cb</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>
attribute_deprecated <span class="hl kwb">void</span> <span class="hl kwd">av_format_set_open_cb</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVOpenCallback callback<span class="hl opt">);</span>
<span class="hl ppc">#endif</span>

<span class="hl com">/**</span>
<span class="hl com"> * This function will cause global side data to be injected in the next packet</span>
<span class="hl com"> * of each stream as well as after any subsequent seek.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_format_inject_global_side_data</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Returns the method used to set ctx-&gt;duration.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.</span>
<span class="hl com"> */</span>
<span class="hl kwb">enum</span> AVDurationEstimationMethod <span class="hl kwd">av_fmt_ctx_get_duration_estimation_method</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVFormatContext<span class="hl opt">*</span> ctx<span class="hl opt">);</span>

<span class="hl kwc">typedef</span> <span class="hl kwb">struct</span> AVPacketList <span class="hl opt">{</span>
    AVPacket pkt<span class="hl opt">;</span>
    <span class="hl kwb">struct</span> AVPacketList <span class="hl opt">*</span>next<span class="hl opt">;</span>
<span class="hl opt">}</span> AVPacketList<span class="hl opt">;</span>


<span class="hl com">/**</span>
<span class="hl com"> * &#64;defgroup lavf_core Core functions</span>
<span class="hl com"> * &#64;ingroup libavf</span>
<span class="hl com"> *</span>
<span class="hl com"> * Functions for querying libavformat capabilities, allocating core structures,</span>
<span class="hl com"> * etc.</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return the LIBAVFORMAT_VERSION_INT constant.</span>
<span class="hl com"> */</span>
<span class="hl kwb">unsigned</span> <span class="hl kwd">avformat_version</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return the libavformat build-time configuration.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const char</span> <span class="hl opt">*</span><span class="hl kwd">avformat_configuration</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return the libavformat license.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const char</span> <span class="hl opt">*</span><span class="hl kwd">avformat_license</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Initialize libavformat and register all the muxers, demuxers and</span>
<span class="hl com"> * protocols. If you do not call this function, then you can select</span>
<span class="hl com"> * exactly which formats you want to support.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_register_input_format()</span>
<span class="hl com"> * &#64;see av_register_output_format()</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_register_all</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl kwb">void</span> <span class="hl kwd">av_register_input_format</span><span class="hl opt">(</span>AVInputFormat <span class="hl opt">*</span>format<span class="hl opt">);</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_register_output_format</span><span class="hl opt">(</span>AVOutputFormat <span class="hl opt">*</span>format<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Do global initialization of network components. This is optional,</span>
<span class="hl com"> * but recommended, since it avoids the overhead of implicitly</span>
<span class="hl com"> * doing the setup for each session.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Calling this function will become mandatory if using network</span>
<span class="hl com"> * protocols at some major version bump.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_network_init</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Undo the initialization done by avformat_network_init.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_network_deinit</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * If f is NULL, returns the first registered input format,</span>
<span class="hl com"> * if f is non-NULL, returns the next registered input format after f</span>
<span class="hl com"> * or NULL if f is the last one.</span>
<span class="hl com"> */</span>
AVInputFormat  <span class="hl opt">*</span><span class="hl kwd">av_iformat_next</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVInputFormat  <span class="hl opt">*</span>f<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * If f is NULL, returns the first registered output format,</span>
<span class="hl com"> * if f is non-NULL, returns the next registered output format after f</span>
<span class="hl com"> * or NULL if f is the last one.</span>
<span class="hl com"> */</span>
AVOutputFormat <span class="hl opt">*</span><span class="hl kwd">av_oformat_next</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVOutputFormat <span class="hl opt">*</span>f<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Allocate an AVFormatContext.</span>
<span class="hl com"> * avformat_free_context() can be used to free the context and everything</span>
<span class="hl com"> * allocated by the framework within it.</span>
<span class="hl com"> */</span>
AVFormatContext <span class="hl opt">*</span><span class="hl kwd">avformat_alloc_context</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Free an AVFormatContext and all its streams.</span>
<span class="hl com"> * &#64;param s context to free</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">avformat_free_context</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the AVClass for AVFormatContext. It can be used in combination with</span>
<span class="hl com"> * AV_OPT_SEARCH_FAKE_OBJ for examining options.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_opt_find().</span>
<span class="hl com"> */</span>
<span class="hl kwb">const</span> AVClass <span class="hl opt">*</span><span class="hl kwd">avformat_get_class</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Add a new stream to a media file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * When demuxing, it is called by the demuxer in read_header(). If the</span>
<span class="hl com"> * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also</span>
<span class="hl com"> * be called in read_packet().</span>
<span class="hl com"> *</span>
<span class="hl com"> * When muxing, should be called by the user before avformat_write_header().</span>
<span class="hl com"> *</span>
<span class="hl com"> * User is required to call avcodec_close() and avformat_free_context() to</span>
<span class="hl com"> * clean up the allocation by avformat_new_stream().</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;param c If non-NULL, the AVCodecContext corresponding to the new stream</span>
<span class="hl com"> * will be initialized to use this codec. This is needed for e.g. codec-specific</span>
<span class="hl com"> * defaults to be set, so codec should be provided if it is known.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return newly created stream or NULL on error.</span>
<span class="hl com"> */</span>
AVStream <span class="hl opt">*</span><span class="hl kwd">avformat_new_stream</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">const</span> AVCodec <span class="hl opt">*</span>c<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Wrap an existing array as stream side data.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param st stream</span>
<span class="hl com"> * &#64;param type side information type</span>
<span class="hl com"> * &#64;param data the side data array. It must be allocated with the av_malloc()</span>
<span class="hl com"> *             family of functions. The ownership of the data is transferred to</span>
<span class="hl com"> *             st.</span>
<span class="hl com"> * &#64;param size side information size</span>
<span class="hl com"> * &#64;return zero on success, a negative AVERROR code on failure. On failure,</span>
<span class="hl com"> *         the stream is unchanged and the data remains owned by the caller.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_stream_add_side_data</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>st<span class="hl opt">,</span> <span class="hl kwb">enum</span> AVPacketSideDataType type<span class="hl opt">,</span>
                            <span class="hl kwb">uint8_t</span> <span class="hl opt">*</span>data<span class="hl opt">,</span> <span class="hl kwb">size_t</span> size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Allocate new information from stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param stream stream</span>
<span class="hl com"> * &#64;param type desired side information type</span>
<span class="hl com"> * &#64;param size side information size</span>
<span class="hl com"> * &#64;return pointer to fresh allocated data or NULL otherwise</span>
<span class="hl com"> */</span>
<span class="hl kwb">uint8_t</span> <span class="hl opt">*</span><span class="hl kwd">av_stream_new_side_data</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>stream<span class="hl opt">,</span>
                                 <span class="hl kwb">enum</span> AVPacketSideDataType type<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>
<span class="hl com">/**</span>
<span class="hl com"> * Get side information from stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param stream stream</span>
<span class="hl com"> * &#64;param type desired side information type</span>
<span class="hl com"> * &#64;param size pointer for side information size to store (optional)</span>
<span class="hl com"> * &#64;return pointer to data if present or NULL otherwise</span>
<span class="hl com"> */</span>
<span class="hl ppc">#if FF_API_NOCONST_GET_SIDE_DATA</span>
<span class="hl kwb">uint8_t</span> <span class="hl opt">*</span><span class="hl kwd">av_stream_get_side_data</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>stream<span class="hl opt">,</span>
                                 <span class="hl kwb">enum</span> AVPacketSideDataType type<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">*</span>size<span class="hl opt">);</span>
<span class="hl ppc">#else</span>
<span class="hl kwb">uint8_t</span> <span class="hl opt">*</span><span class="hl kwd">av_stream_get_side_data</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>stream<span class="hl opt">,</span>
                                 <span class="hl kwb">enum</span> AVPacketSideDataType type<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">*</span>size<span class="hl opt">);</span>
<span class="hl ppc">#endif</span>

AVProgram <span class="hl opt">*</span><span class="hl kwd">av_new_program</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> id<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>


<span class="hl com">/**</span>
<span class="hl com"> * Allocate an AVFormatContext for an output format.</span>
<span class="hl com"> * avformat_free_context() can be used to free the context and</span>
<span class="hl com"> * everything allocated by the framework within it.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param *ctx is set to the created format context, or to NULL in</span>
<span class="hl com"> * case of failure</span>
<span class="hl com"> * &#64;param oformat format to use for allocating the context, if NULL</span>
<span class="hl com"> * format_name and filename are used instead</span>
<span class="hl com"> * &#64;param format_name the name of output format to use for allocating the</span>
<span class="hl com"> * context, if NULL filename is used instead</span>
<span class="hl com"> * &#64;param filename the name of the filename to use for allocating the</span>
<span class="hl com"> * context, may be NULL</span>
<span class="hl com"> * &#64;return &gt;= 0 in case of success, a negative AVERROR code in case of</span>
<span class="hl com"> * failure</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_alloc_output_context2</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">**</span>ctx<span class="hl opt">,</span> AVOutputFormat <span class="hl opt">*</span>oformat<span class="hl opt">,</span>
                                   <span class="hl kwb">const char</span> <span class="hl opt">*</span>format_name<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;addtogroup lavf_decoding</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * Find AVInputFormat based on the short name of the input format.</span>
<span class="hl com"> */</span>
AVInputFormat <span class="hl opt">*</span><span class="hl kwd">av_find_input_format</span><span class="hl opt">(</span><span class="hl kwb">const char</span> <span class="hl opt">*</span>short_name<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the file format.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param pd        data to be probed</span>
<span class="hl com"> * &#64;param is_opened Whether the file is already opened; determines whether</span>
<span class="hl com"> *                  demuxers with or without AVFMT_NOFILE are probed.</span>
<span class="hl com"> */</span>
AVInputFormat <span class="hl opt">*</span><span class="hl kwd">av_probe_input_format</span><span class="hl opt">(</span>AVProbeData <span class="hl opt">*</span>pd<span class="hl opt">,</span> <span class="hl kwb">int</span> is_opened<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the file format.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param pd        data to be probed</span>
<span class="hl com"> * &#64;param is_opened Whether the file is already opened; determines whether</span>
<span class="hl com"> *                  demuxers with or without AVFMT_NOFILE are probed.</span>
<span class="hl com"> * &#64;param score_max A probe score larger that this is required to accept a</span>
<span class="hl com"> *                  detection, the variable is set to the actual detection</span>
<span class="hl com"> *                  score afterwards.</span>
<span class="hl com"> *                  If the score is &lt;= AVPROBE_SCORE_MAX / 4 it is recommended</span>
<span class="hl com"> *                  to retry with a larger probe buffer.</span>
<span class="hl com"> */</span>
AVInputFormat <span class="hl opt">*</span><span class="hl kwd">av_probe_input_format2</span><span class="hl opt">(</span>AVProbeData <span class="hl opt">*</span>pd<span class="hl opt">,</span> <span class="hl kwb">int</span> is_opened<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">*</span>score_max<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the file format.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param is_opened Whether the file is already opened; determines whether</span>
<span class="hl com"> *                  demuxers with or without AVFMT_NOFILE are probed.</span>
<span class="hl com"> * &#64;param score_ret The score of the best detection.</span>
<span class="hl com"> */</span>
AVInputFormat <span class="hl opt">*</span><span class="hl kwd">av_probe_input_format3</span><span class="hl opt">(</span>AVProbeData <span class="hl opt">*</span>pd<span class="hl opt">,</span> <span class="hl kwb">int</span> is_opened<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">*</span>score_ret<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Probe a bytestream to determine the input format. Each time a probe returns</span>
<span class="hl com"> * with a score that is too low, the probe buffer size is increased and another</span>
<span class="hl com"> * attempt is made. When the maximum probe size is reached, the input format</span>
<span class="hl com"> * with the highest score is returned.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param pb the bytestream to probe</span>
<span class="hl com"> * &#64;param fmt the input format is put here</span>
<span class="hl com"> * &#64;param url the url of the stream</span>
<span class="hl com"> * &#64;param logctx the log context</span>
<span class="hl com"> * &#64;param offset the offset within the bytestream to probe from</span>
<span class="hl com"> * &#64;param max_probe_size the maximum probe buffer size (zero for default)</span>
<span class="hl com"> * &#64;return the score in case of success, a negative value corresponding to an</span>
<span class="hl com"> *         the maximal score is AVPROBE_SCORE_MAX</span>
<span class="hl com"> * AVERROR code otherwise</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_probe_input_buffer2</span><span class="hl opt">(</span>AVIOContext <span class="hl opt">*</span>pb<span class="hl opt">,</span> AVInputFormat <span class="hl opt">**</span>fmt<span class="hl opt">,</span>
                           <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span> <span class="hl kwb">void</span> <span class="hl opt">*</span>logctx<span class="hl opt">,</span>
                           <span class="hl kwb">unsigned int</span> offset<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span> max_probe_size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Like av_probe_input_buffer2() but returns 0 on success</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_probe_input_buffer</span><span class="hl opt">(</span>AVIOContext <span class="hl opt">*</span>pb<span class="hl opt">,</span> AVInputFormat <span class="hl opt">**</span>fmt<span class="hl opt">,</span>
                          <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span> <span class="hl kwb">void</span> <span class="hl opt">*</span>logctx<span class="hl opt">,</span>
                          <span class="hl kwb">unsigned int</span> offset<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span> max_probe_size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Open an input stream and read the header. The codecs are not opened.</span>
<span class="hl com"> * The stream must be closed with avformat_close_input().</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).</span>
<span class="hl com"> *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this</span>
<span class="hl com"> *           function and written into ps.</span>
<span class="hl com"> *           Note that a user-supplied AVFormatContext will be freed on failure.</span>
<span class="hl com"> * &#64;param url URL of the stream to open.</span>
<span class="hl com"> * &#64;param fmt If non-NULL, this parameter forces a specific input format.</span>
<span class="hl com"> *            Otherwise the format is autodetected.</span>
<span class="hl com"> * &#64;param options  A dictionary filled with AVFormatContext and demuxer-private options.</span>
<span class="hl com"> *                 On return this parameter will be destroyed and replaced with a dict containing</span>
<span class="hl com"> *                 options that were not found. May be NULL.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return 0 on success, a negative AVERROR on failure.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;note If you want to use custom IO, preallocate the format context and set its pb field.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_open_input</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">**</span>ps<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span> AVInputFormat <span class="hl opt">*</span>fmt<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

attribute_deprecated
<span class="hl kwb">int</span> <span class="hl kwd">av_demuxer_open</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ic<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Read packets of a media file to get stream information. This</span>
<span class="hl com"> * is useful for file formats with no headers such as MPEG. This</span>
<span class="hl com"> * function also computes the real framerate in case of MPEG-2 repeat</span>
<span class="hl com"> * frame mode.</span>
<span class="hl com"> * The logical file position is not changed by this function;</span>
<span class="hl com"> * examined packets may be buffered for later processing.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ic media file handle</span>
<span class="hl com"> * &#64;param options  If non-NULL, an ic.nb_streams long array of pointers to</span>
<span class="hl com"> *                 dictionaries, where i-th member contains options for</span>
<span class="hl com"> *                 codec corresponding to i-th stream.</span>
<span class="hl com"> *                 On return each dictionary will be filled with options that were not found.</span>
<span class="hl com"> * &#64;return &gt;=0 if OK, AVERROR_xxx on error</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;note this function isn&apos;t guaranteed to open all the codecs, so</span>
<span class="hl com"> *       options being non-empty at return is a perfectly normal behavior.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;todo Let the user decide somehow what information is needed so that</span>
<span class="hl com"> *       we do not waste time getting stuff the user does not need.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_find_stream_info</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ic<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Find the programs which belong to a given stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ic    media file handle</span>
<span class="hl com"> * &#64;param last  the last found program, the search will start after this</span>
<span class="hl com"> *              program, or from the beginning if it is NULL</span>
<span class="hl com"> * &#64;param s     stream index</span>
<span class="hl com"> * &#64;return the next program which belongs to s, NULL if no program is found or</span>
<span class="hl com"> *         the last program is not among the programs of ic.</span>
<span class="hl com"> */</span>
AVProgram <span class="hl opt">*</span><span class="hl kwd">av_find_program_from_stream</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ic<span class="hl opt">,</span> AVProgram <span class="hl opt">*</span>last<span class="hl opt">,</span> <span class="hl kwb">int</span> s<span class="hl opt">);</span>

<span class="hl kwb">void</span> <span class="hl kwd">av_program_add_stream_index</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ac<span class="hl opt">,</span> <span class="hl kwb">int</span> progid<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span> idx<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Find the &quot;best&quot; stream in the file.</span>
<span class="hl com"> * The best stream is determined according to various heuristics as the most</span>
<span class="hl com"> * likely to be what the user expects.</span>
<span class="hl com"> * If the decoder parameter is non-NULL, av_find_best_stream will find the</span>
<span class="hl com"> * default decoder for the stream&apos;s codec; streams for which no decoder can</span>
<span class="hl com"> * be found are ignored.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ic                media file handle</span>
<span class="hl com"> * &#64;param type              stream type: video, audio, subtitles, etc.</span>
<span class="hl com"> * &#64;param wanted_stream_nb  user-requested stream number,</span>
<span class="hl com"> *                          or -1 for automatic selection</span>
<span class="hl com"> * &#64;param related_stream    try to find a stream related (eg. in the same</span>
<span class="hl com"> *                          program) to this one, or -1 if none</span>
<span class="hl com"> * &#64;param decoder_ret       if non-NULL, returns the decoder for the</span>
<span class="hl com"> *                          selected stream</span>
<span class="hl com"> * &#64;param flags             flags; none are currently defined</span>
<span class="hl com"> * &#64;return  the non-negative stream number in case of success,</span>
<span class="hl com"> *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type</span>
<span class="hl com"> *          could be found,</span>
<span class="hl com"> *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder</span>
<span class="hl com"> * &#64;note  If av_find_best_stream returns successfully and decoder_ret is not</span>
<span class="hl com"> *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_find_best_stream</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ic<span class="hl opt">,</span>
                        <span class="hl kwb">enum</span> AVMediaType type<span class="hl opt">,</span>
                        <span class="hl kwb">int</span> wanted_stream_nb<span class="hl opt">,</span>
                        <span class="hl kwb">int</span> related_stream<span class="hl opt">,</span>
                        AVCodec <span class="hl opt">**</span>decoder_ret<span class="hl opt">,</span>
                        <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return the next frame of a stream.</span>
<span class="hl com"> * This function returns what is stored in the file, and does not validate</span>
<span class="hl com"> * that what is there are valid frames for the decoder. It will split what is</span>
<span class="hl com"> * stored in the file into frames and return one for each call. It will not</span>
<span class="hl com"> * omit invalid data between valid frames so as to give the decoder the maximum</span>
<span class="hl com"> * information possible for decoding.</span>
<span class="hl com"> *</span>
<span class="hl com"> * If pkt-&gt;buf is NULL, then the packet is valid until the next</span>
<span class="hl com"> * av_read_frame() or until avformat_close_input(). Otherwise the packet</span>
<span class="hl com"> * is valid indefinitely. In both cases the packet must be freed with</span>
<span class="hl com"> * av_packet_unref when it is no longer needed. For video, the packet contains</span>
<span class="hl com"> * exactly one frame. For audio, it contains an integer number of frames if each</span>
<span class="hl com"> * frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames</span>
<span class="hl com"> * have a variable size (e.g. MPEG audio), then it contains one frame.</span>
<span class="hl com"> *</span>
<span class="hl com"> * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct</span>
<span class="hl com"> * values in AVStream.time_base units (and guessed if the format cannot</span>
<span class="hl com"> * provide them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format</span>
<span class="hl com"> * has B-frames, so it is better to rely on pkt-&gt;dts if you do not</span>
<span class="hl com"> * decompress the payload.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return 0 if OK, &lt; 0 on error or end of file</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_read_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Seek to the keyframe at timestamp.</span>
<span class="hl com"> * &apos;timestamp&apos; in &apos;stream_index&apos;.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;param stream_index If stream_index is (-1), a default</span>
<span class="hl com"> * stream is selected, and timestamp is automatically converted</span>
<span class="hl com"> * from AV_TIME_BASE units to the stream specific time_base.</span>
<span class="hl com"> * &#64;param timestamp Timestamp in AVStream.time_base units</span>
<span class="hl com"> *        or, if no stream is specified, in AV_TIME_BASE units.</span>
<span class="hl com"> * &#64;param flags flags which select direction and seeking mode</span>
<span class="hl com"> * &#64;return &gt;= 0 on success</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_seek_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> timestamp<span class="hl opt">,</span>
                  <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Seek to timestamp ts.</span>
<span class="hl com"> * Seeking will be done so that the point from which all active streams</span>
<span class="hl com"> * can be presented successfully will be closest to ts and within min/max_ts.</span>
<span class="hl com"> * Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</span>
<span class="hl com"> *</span>
<span class="hl com"> * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and</span>
<span class="hl com"> * are the file position (this may not be supported by all demuxers).</span>
<span class="hl com"> * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames</span>
<span class="hl com"> * in the stream with stream_index (this may not be supported by all demuxers).</span>
<span class="hl com"> * Otherwise all timestamps are in units of the stream selected by stream_index</span>
<span class="hl com"> * or if stream_index is -1, in AV_TIME_BASE units.</span>
<span class="hl com"> * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as</span>
<span class="hl com"> * keyframes (this may not be supported by all demuxers).</span>
<span class="hl com"> * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;param stream_index index of the stream which is used as time base reference</span>
<span class="hl com"> * &#64;param min_ts smallest acceptable timestamp</span>
<span class="hl com"> * &#64;param ts target timestamp</span>
<span class="hl com"> * &#64;param max_ts largest acceptable timestamp</span>
<span class="hl com"> * &#64;param flags flags</span>
<span class="hl com"> * &#64;return &gt;=0 on success, error code otherwise</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;note This is part of the new seek API which is still under construction.</span>
<span class="hl com"> *       Thus do not use this yet. It may change at any time, do not expect</span>
<span class="hl com"> *       ABI compatibility yet!</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_seek_file</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> min_ts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> ts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> max_ts<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Discard all internally buffered data. This can be useful when dealing with</span>
<span class="hl com"> * discontinuities in the byte stream. Generally works only with formats that</span>
<span class="hl com"> * can resync. This includes headerless formats like MPEG-TS/TS but should also</span>
<span class="hl com"> * work with NUT, Ogg and in a limited way AVI for example.</span>
<span class="hl com"> *</span>
<span class="hl com"> * The set of streams, the detected duration, stream parameters and codecs do</span>
<span class="hl com"> * not change when calling this function. If you want a complete reset, it&apos;s</span>
<span class="hl com"> * better to open a new AVFormatContext.</span>
<span class="hl com"> *</span>
<span class="hl com"> * This does not flush the AVIOContext (s-&gt;pb). If necessary, call</span>
<span class="hl com"> * avio_flush(s-&gt;pb) before calling this function.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;return &gt;=0 on success, error code otherwise</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_flush</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Start playing a network-based stream (e.g. RTSP stream) at the</span>
<span class="hl com"> * current position.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_read_play</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Pause a network-based stream (e.g. RTSP stream).</span>
<span class="hl com"> *</span>
<span class="hl com"> * Use av_read_play() to resume it.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_read_pause</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Close an opened input AVFormatContext. Free it and all its contents</span>
<span class="hl com"> * and set *s to NULL.</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">avformat_close_input</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">**</span>s<span class="hl opt">);</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl ppc">#define AVSEEK_FLAG_BACKWARD 1</span> <span class="hl slc">///&lt; seek backward</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVSEEK_FLAG_BYTE     2</span> <span class="hl slc">///&lt; seeking based on position in bytes</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVSEEK_FLAG_ANY      4</span> <span class="hl slc">///&lt; seek to any frame, even non-keyframes</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVSEEK_FLAG_FRAME    8</span> <span class="hl slc">///&lt; seeking based on frame number</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;addtogroup lavf_encoding</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> */</span>

<span class="hl ppc">#define AVSTREAM_INIT_IN_WRITE_HEADER 0</span> <span class="hl slc">///&lt; stream parameters initialized in avformat_write_header</span>
<span class="hl ppc"></span><span class="hl ppc">#define AVSTREAM_INIT_IN_INIT_OUTPUT  1</span> <span class="hl slc">///&lt; stream parameters initialized in avformat_init_output</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * Allocate the stream private data and write the stream header to</span>
<span class="hl com"> * an output media file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s Media file handle, must be allocated with avformat_alloc_context().</span>
<span class="hl com"> *          Its oformat field must be set to the desired output format;</span>
<span class="hl com"> *          Its pb field must be set to an already opened AVIOContext.</span>
<span class="hl com"> * &#64;param options  An AVDictionary filled with AVFormatContext and muxer-private options.</span>
<span class="hl com"> *                 On return this parameter will be destroyed and replaced with a dict containing</span>
<span class="hl com"> *                 options that were not found. May be NULL.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,</span>
<span class="hl com"> *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,</span>
<span class="hl com"> *         negative AVERROR on failure.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.</span>
<span class="hl com"> */</span>
av_warn_unused_result
<span class="hl kwb">int</span> <span class="hl kwd">avformat_write_header</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Allocate the stream private data and initialize the codec, but do not write the header.</span>
<span class="hl com"> * May optionally be used before avformat_write_header to initialize stream parameters</span>
<span class="hl com"> * before actually writing the header.</span>
<span class="hl com"> * If using this function, do not pass the same options to avformat_write_header.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s Media file handle, must be allocated with avformat_alloc_context().</span>
<span class="hl com"> *          Its oformat field must be set to the desired output format;</span>
<span class="hl com"> *          Its pb field must be set to an already opened AVIOContext.</span>
<span class="hl com"> * &#64;param options  An AVDictionary filled with AVFormatContext and muxer-private options.</span>
<span class="hl com"> *                 On return this parameter will be destroyed and replaced with a dict containing</span>
<span class="hl com"> *                 options that were not found. May be NULL.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,</span>
<span class="hl com"> *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,</span>
<span class="hl com"> *         negative AVERROR on failure.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.</span>
<span class="hl com"> */</span>
av_warn_unused_result
<span class="hl kwb">int</span> <span class="hl kwd">avformat_init_output</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVDictionary <span class="hl opt">**</span>options<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Write a packet to an output media file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * This function passes the packet directly to the muxer, without any buffering</span>
<span class="hl com"> * or reordering. The caller is responsible for correctly interleaving the</span>
<span class="hl com"> * packets if the format requires it. Callers that want libavformat to handle</span>
<span class="hl com"> * the interleaving should call av_interleaved_write_frame() instead of this</span>
<span class="hl com"> * function.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;param pkt The packet containing the data to be written. Note that unlike</span>
<span class="hl com"> *            av_interleaved_write_frame(), this function does not take</span>
<span class="hl com"> *            ownership of the packet passed to it (though some muxers may make</span>
<span class="hl com"> *            an internal reference to the input packet).</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            This parameter can be NULL (at any time, not just at the end), in</span>
<span class="hl com"> *            order to immediately flush data buffered within the muxer, for</span>
<span class="hl com"> *            muxers that buffer up data internally before writing it to the</span>
<span class="hl com"> *            output.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            Packet&apos;s &#64;ref AVPacket.stream_index &quot;stream_index&quot; field must be</span>
<span class="hl com"> *            set to the index of the corresponding stream in &#64;ref</span>
<span class="hl com"> *            AVFormatContext.streams &quot;s-&gt;streams&quot;.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            The timestamps (&#64;ref AVPacket.pts &quot;pts&quot;, &#64;ref AVPacket.dts &quot;dts&quot;)</span>
<span class="hl com"> *            must be set to correct values in the stream&apos;s timebase (unless the</span>
<span class="hl com"> *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then</span>
<span class="hl com"> *            they can be set to AV_NOPTS_VALUE).</span>
<span class="hl com"> *            The dts for subsequent packets passed to this function must be strictly</span>
<span class="hl com"> *            increasing when compared in their respective timebases (unless the</span>
<span class="hl com"> *            output format is flagged with the AVFMT_TS_NONSTRICT, then they</span>
<span class="hl com"> *            merely have to be nondecreasing).  &#64;ref AVPacket.duration</span>
<span class="hl com"> *            &quot;duration&quot;) should also be set if known.</span>
<span class="hl com"> * &#64;return &lt; 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_interleaved_write_frame()</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_write_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Write a packet to an output media file ensuring correct interleaving.</span>
<span class="hl com"> *</span>
<span class="hl com"> * This function will buffer the packets internally as needed to make sure the</span>
<span class="hl com"> * packets in the output file are properly interleaved in the order of</span>
<span class="hl com"> * increasing dts. Callers doing their own interleaving should call</span>
<span class="hl com"> * av_write_frame() instead of this function.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Using this function instead of av_write_frame() can give muxers advance</span>
<span class="hl com"> * knowledge of future packets, improving e.g. the behaviour of the mp4</span>
<span class="hl com"> * muxer for VFR content in fragmenting mode.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;param pkt The packet containing the data to be written.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            If the packet is reference-counted, this function will take</span>
<span class="hl com"> *            ownership of this reference and unreference it later when it sees</span>
<span class="hl com"> *            fit.</span>
<span class="hl com"> *            The caller must not access the data through this reference after</span>
<span class="hl com"> *            this function returns. If the packet is not reference-counted,</span>
<span class="hl com"> *            libavformat will make a copy.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            This parameter can be NULL (at any time, not just at the end), to</span>
<span class="hl com"> *            flush the interleaving queues.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            Packet&apos;s &#64;ref AVPacket.stream_index &quot;stream_index&quot; field must be</span>
<span class="hl com"> *            set to the index of the corresponding stream in &#64;ref</span>
<span class="hl com"> *            AVFormatContext.streams &quot;s-&gt;streams&quot;.</span>
<span class="hl com"> *            &lt;br&gt;</span>
<span class="hl com"> *            The timestamps (&#64;ref AVPacket.pts &quot;pts&quot;, &#64;ref AVPacket.dts &quot;dts&quot;)</span>
<span class="hl com"> *            must be set to correct values in the stream&apos;s timebase (unless the</span>
<span class="hl com"> *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then</span>
<span class="hl com"> *            they can be set to AV_NOPTS_VALUE).</span>
<span class="hl com"> *            The dts for subsequent packets in one stream must be strictly</span>
<span class="hl com"> *            increasing (unless the output format is flagged with the</span>
<span class="hl com"> *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).</span>
<span class="hl com"> *            &#64;ref AVPacket.duration &quot;duration&quot;) should also be set if known.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return 0 on success, a negative AVERROR on error. Libavformat will always</span>
<span class="hl com"> *         take care of freeing the packet, even if this function fails.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_write_frame(), AVFormatContext.max_interleave_delta</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_interleaved_write_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Write an uncoded frame to an output media file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * The frame must be correctly interleaved according to the container</span>
<span class="hl com"> * specification; if not, then av_interleaved_write_frame() must be used.</span>
<span class="hl com"> *</span>
<span class="hl com"> * See av_interleaved_write_frame() for details.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_write_uncoded_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span>
                           AVFrame <span class="hl opt">*</span>frame<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Write an uncoded frame to an output media file.</span>
<span class="hl com"> *</span>
<span class="hl com"> * If the muxer supports it, this function makes it possible to write an AVFrame</span>
<span class="hl com"> * structure directly, without encoding it into a packet.</span>
<span class="hl com"> * It is mostly useful for devices and similar special muxers that use raw</span>
<span class="hl com"> * video or PCM data and will not serialize it into a byte stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * To test whether it is possible to use it with a given muxer and stream,</span>
<span class="hl com"> * use av_write_uncoded_frame_query().</span>
<span class="hl com"> *</span>
<span class="hl com"> * The caller gives up ownership of the frame and must not access it</span>
<span class="hl com"> * afterwards.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return  &gt;=0 for success, a negative code on error</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_interleaved_write_uncoded_frame</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">,</span>
                                       AVFrame <span class="hl opt">*</span>frame<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Test whether a muxer supports uncoded frame.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return  &gt;=0 if an uncoded frame can be written to that muxer and stream,</span>
<span class="hl com"> *          &lt;0 if not</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_write_uncoded_frame_query</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream_index<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Write the stream trailer to an output media file and free the</span>
<span class="hl com"> * file private data.</span>
<span class="hl com"> *</span>
<span class="hl com"> * May only be called after a successful call to avformat_write_header.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param s media file handle</span>
<span class="hl com"> * &#64;return 0 if OK, AVERROR_xxx on error</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_write_trailer</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return the output format in the list of registered output formats</span>
<span class="hl com"> * which best matches the provided parameters, or return NULL if</span>
<span class="hl com"> * there is no match.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param short_name if non-NULL checks if short_name matches with the</span>
<span class="hl com"> * names of the registered formats</span>
<span class="hl com"> * &#64;param filename if non-NULL checks if filename terminates with the</span>
<span class="hl com"> * extensions of the registered formats</span>
<span class="hl com"> * &#64;param mime_type if non-NULL checks if mime_type matches with the</span>
<span class="hl com"> * MIME type of the registered formats</span>
<span class="hl com"> */</span>
AVOutputFormat <span class="hl opt">*</span><span class="hl kwd">av_guess_format</span><span class="hl opt">(</span><span class="hl kwb">const char</span> <span class="hl opt">*</span>short_name<span class="hl opt">,</span>
                                <span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">,</span>
                                <span class="hl kwb">const char</span> <span class="hl opt">*</span>mime_type<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the codec ID based upon muxer and filename.</span>
<span class="hl com"> */</span>
<span class="hl kwb">enum</span> AVCodecID <span class="hl kwd">av_guess_codec</span><span class="hl opt">(</span>AVOutputFormat <span class="hl opt">*</span>fmt<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>short_name<span class="hl opt">,</span>
                            <span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>mime_type<span class="hl opt">,</span>
                            <span class="hl kwb">enum</span> AVMediaType type<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get timing information for the data currently output.</span>
<span class="hl com"> * The exact meaning of &quot;currently output&quot; depends on the format.</span>
<span class="hl com"> * It is mostly relevant for devices that have an internal buffer and/or</span>
<span class="hl com"> * work in real time.</span>
<span class="hl com"> * &#64;param s          media file handle</span>
<span class="hl com"> * &#64;param stream     stream in the media file</span>
<span class="hl com"> * &#64;param[out] dts   DTS of the last packet output for the stream, in stream</span>
<span class="hl com"> *                   time_base units</span>
<span class="hl com"> * &#64;param[out] wall  absolute time when that packet whas output,</span>
<span class="hl com"> *                   in microsecond</span>
<span class="hl com"> * &#64;return  0 if OK, AVERROR(ENOSYS) if the format does not support it</span>
<span class="hl com"> * Note: some formats or devices may not allow to measure dts and wall</span>
<span class="hl com"> * atomically.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_get_output_timestamp</span><span class="hl opt">(</span><span class="hl kwb">struct</span> AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> <span class="hl kwb">int</span> stream<span class="hl opt">,</span>
                            <span class="hl kwb">int64_t</span> <span class="hl opt">*</span>dts<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> <span class="hl opt">*</span>wall<span class="hl opt">);</span>


<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>


<span class="hl com">/**</span>
<span class="hl com"> * &#64;defgroup lavf_misc Utility functions</span>
<span class="hl com"> * &#64;ingroup libavf</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> *</span>
<span class="hl com"> * Miscellaneous utility functions related to both muxing and demuxing</span>
<span class="hl com"> * (or neither).</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * Send a nice hexadecimal dump of a buffer to the specified file stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param f The file stream pointer where the dump should be sent to.</span>
<span class="hl com"> * &#64;param buf buffer</span>
<span class="hl com"> * &#64;param size buffer size</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_hex_dump</span><span class="hl opt">(</span><span class="hl kwb">FILE</span> <span class="hl opt">*</span>f<span class="hl opt">,</span> <span class="hl kwb">const uint8_t</span> <span class="hl opt">*</span>buf<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Send a nice hexadecimal dump of a buffer to the log.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param avcl A pointer to an arbitrary struct of which the first field is a</span>
<span class="hl com"> * pointer to an AVClass struct.</span>
<span class="hl com"> * &#64;param level The importance level of the message, lower values signifying</span>
<span class="hl com"> * higher importance.</span>
<span class="hl com"> * &#64;param buf buffer</span>
<span class="hl com"> * &#64;param size buffer size</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_hex_dump_log</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">*</span>avcl<span class="hl opt">,</span> <span class="hl kwb">int</span> level<span class="hl opt">,</span> <span class="hl kwb">const uint8_t</span> <span class="hl opt">*</span>buf<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Send a nice dump of a packet to the specified file stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param f The file stream pointer where the dump should be sent to.</span>
<span class="hl com"> * &#64;param pkt packet to dump</span>
<span class="hl com"> * &#64;param dump_payload True if the payload must be displayed, too.</span>
<span class="hl com"> * &#64;param st AVStream that the packet belongs to</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_pkt_dump2</span><span class="hl opt">(</span><span class="hl kwb">FILE</span> <span class="hl opt">*</span>f<span class="hl opt">,</span> <span class="hl kwb">const</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">,</span> <span class="hl kwb">int</span> dump_payload<span class="hl opt">,</span> <span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>st<span class="hl opt">);</span>


<span class="hl com">/**</span>
<span class="hl com"> * Send a nice dump of a packet to the log.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param avcl A pointer to an arbitrary struct of which the first field is a</span>
<span class="hl com"> * pointer to an AVClass struct.</span>
<span class="hl com"> * &#64;param level The importance level of the message, lower values signifying</span>
<span class="hl com"> * higher importance.</span>
<span class="hl com"> * &#64;param pkt packet to dump</span>
<span class="hl com"> * &#64;param dump_payload True if the payload must be displayed, too.</span>
<span class="hl com"> * &#64;param st AVStream that the packet belongs to</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_pkt_dump_log2</span><span class="hl opt">(</span><span class="hl kwb">void</span> <span class="hl opt">*</span>avcl<span class="hl opt">,</span> <span class="hl kwb">int</span> level<span class="hl opt">,</span> <span class="hl kwb">const</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">,</span> <span class="hl kwb">int</span> dump_payload<span class="hl opt">,</span>
                      <span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>st<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the AVCodecID for the given codec tag tag.</span>
<span class="hl com"> * If no codec id is found returns AV_CODEC_ID_NONE.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param tags list of supported codec_id-codec_tag pairs, as stored</span>
<span class="hl com"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span>
<span class="hl com"> * &#64;param tag  codec tag to match to a codec ID</span>
<span class="hl com"> */</span>
<span class="hl kwb">enum</span> AVCodecID <span class="hl kwd">av_codec_get_id</span><span class="hl opt">(</span><span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">*</span>tags<span class="hl opt">,</span> <span class="hl kwb">unsigned int</span> tag<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the codec tag for the given codec id id.</span>
<span class="hl com"> * If no codec tag is found returns 0.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param tags list of supported codec_id-codec_tag pairs, as stored</span>
<span class="hl com"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span>
<span class="hl com"> * &#64;param id   codec ID to match to a codec tag</span>
<span class="hl com"> */</span>
<span class="hl kwb">unsigned int</span> <span class="hl kwd">av_codec_get_tag</span><span class="hl opt">(</span><span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">*</span>tags<span class="hl opt">,</span> <span class="hl kwb">enum</span> AVCodecID id<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the codec tag for the given codec id.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param tags list of supported codec_id - codec_tag pairs, as stored</span>
<span class="hl com"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span>
<span class="hl com"> * &#64;param id codec id that should be searched for in the list</span>
<span class="hl com"> * &#64;param tag A pointer to the found tag</span>
<span class="hl com"> * &#64;return 0 if id was not found in tags, &gt; 0 if it was found</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_codec_get_tag2</span><span class="hl opt">(</span><span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span> <span class="hl kwb">const</span> <span class="hl opt">*</span>tags<span class="hl opt">,</span> <span class="hl kwb">enum</span> AVCodecID id<span class="hl opt">,</span>
                      <span class="hl kwb">unsigned int</span> <span class="hl opt">*</span>tag<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">av_find_default_stream_index</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the index for a specific timestamp.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param st        stream that the timestamp belongs to</span>
<span class="hl com"> * &#64;param timestamp timestamp to retrieve the index for</span>
<span class="hl com"> * &#64;param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond</span>
<span class="hl com"> *                 to the timestamp which is &lt;= the requested one, if backward</span>
<span class="hl com"> *                 is 0, then it will be &gt;=</span>
<span class="hl com"> *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise</span>
<span class="hl com"> * &#64;return &lt; 0 if no such timestamp could be found</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_index_search_timestamp</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>st<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> timestamp<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Add an index entry into a sorted list. Update the entry if the list</span>
<span class="hl com"> * already contains it.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param timestamp timestamp in the time base of the given stream</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_add_index_entry</span><span class="hl opt">(</span>AVStream <span class="hl opt">*</span>st<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> pos<span class="hl opt">,</span> <span class="hl kwb">int64_t</span> timestamp<span class="hl opt">,</span>
                       <span class="hl kwb">int</span> size<span class="hl opt">,</span> <span class="hl kwb">int</span> distance<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>


<span class="hl com">/**</span>
<span class="hl com"> * Split a URL string into components.</span>
<span class="hl com"> *</span>
<span class="hl com"> * The pointers to buffers for storing individual components may be null,</span>
<span class="hl com"> * in order to ignore that component. Buffers for components not found are</span>
<span class="hl com"> * set to empty strings. If the port is not found, it is set to a negative</span>
<span class="hl com"> * value.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param proto the buffer for the protocol</span>
<span class="hl com"> * &#64;param proto_size the size of the proto buffer</span>
<span class="hl com"> * &#64;param authorization the buffer for the authorization</span>
<span class="hl com"> * &#64;param authorization_size the size of the authorization buffer</span>
<span class="hl com"> * &#64;param hostname the buffer for the host name</span>
<span class="hl com"> * &#64;param hostname_size the size of the hostname buffer</span>
<span class="hl com"> * &#64;param port_ptr a pointer to store the port number in</span>
<span class="hl com"> * &#64;param path the buffer for the path</span>
<span class="hl com"> * &#64;param path_size the size of the path buffer</span>
<span class="hl com"> * &#64;param url the URL to split</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_url_split</span><span class="hl opt">(</span><span class="hl kwb">char</span> <span class="hl opt">*</span>proto<span class="hl opt">,</span>         <span class="hl kwb">int</span> proto_size<span class="hl opt">,</span>
                  <span class="hl kwb">char</span> <span class="hl opt">*</span>authorization<span class="hl opt">,</span> <span class="hl kwb">int</span> authorization_size<span class="hl opt">,</span>
                  <span class="hl kwb">char</span> <span class="hl opt">*</span>hostname<span class="hl opt">,</span>      <span class="hl kwb">int</span> hostname_size<span class="hl opt">,</span>
                  <span class="hl kwb">int</span> <span class="hl opt">*</span>port_ptr<span class="hl opt">,</span>
                  <span class="hl kwb">char</span> <span class="hl opt">*</span>path<span class="hl opt">,</span>          <span class="hl kwb">int</span> path_size<span class="hl opt">,</span>
                  <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">);</span>


<span class="hl com">/**</span>
<span class="hl com"> * Print detailed information about the input or output format, such as</span>
<span class="hl com"> * duration, bitrate, streams, container, programs, metadata, side data,</span>
<span class="hl com"> * codec and time base.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ic        the context to analyze</span>
<span class="hl com"> * &#64;param index     index of the stream to dump information about</span>
<span class="hl com"> * &#64;param url       the URL to print, such as source or destination file</span>
<span class="hl com"> * &#64;param is_output Select whether the specified context is an input(0) or output(1)</span>
<span class="hl com"> */</span>
<span class="hl kwb">void</span> <span class="hl kwd">av_dump_format</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ic<span class="hl opt">,</span>
                    <span class="hl kwb">int</span> index<span class="hl opt">,</span>
                    <span class="hl kwb">const char</span> <span class="hl opt">*</span>url<span class="hl opt">,</span>
                    <span class="hl kwb">int</span> is_output<span class="hl opt">);</span>


<span class="hl ppc">#define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1</span> <span class="hl slc">///&lt; Allow multiple %d</span>
<span class="hl ppc"></span>
<span class="hl com">/**</span>
<span class="hl com"> * Return in &apos;buf&apos; the path with &apos;%d&apos; replaced by a number.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Also handles the &apos;%0nd&apos; format where &apos;n&apos; is the total number</span>
<span class="hl com"> * of digits and &apos;%%&apos;.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param buf destination buffer</span>
<span class="hl com"> * &#64;param buf_size destination buffer size</span>
<span class="hl com"> * &#64;param path numbered sequence string</span>
<span class="hl com"> * &#64;param number frame number</span>
<span class="hl com"> * &#64;param flags AV_FRAME_FILENAME_FLAGS_*</span>
<span class="hl com"> * &#64;return 0 if OK, -1 on format error</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_get_frame_filename2</span><span class="hl opt">(</span><span class="hl kwb">char</span> <span class="hl opt">*</span>buf<span class="hl opt">,</span> <span class="hl kwb">int</span> buf_size<span class="hl opt">,</span>
                          <span class="hl kwb">const char</span> <span class="hl opt">*</span>path<span class="hl opt">,</span> <span class="hl kwb">int</span> number<span class="hl opt">,</span> <span class="hl kwb">int</span> flags<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">av_get_frame_filename</span><span class="hl opt">(</span><span class="hl kwb">char</span> <span class="hl opt">*</span>buf<span class="hl opt">,</span> <span class="hl kwb">int</span> buf_size<span class="hl opt">,</span>
                          <span class="hl kwb">const char</span> <span class="hl opt">*</span>path<span class="hl opt">,</span> <span class="hl kwb">int</span> number<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Check whether filename actually is a numbered sequence generator.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param filename possible numbered sequence string</span>
<span class="hl com"> * &#64;return 1 if a valid numbered sequence string, 0 otherwise</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_filename_number_test</span><span class="hl opt">(</span><span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Generate an SDP for an RTP session.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Note, this overwrites the id values of AVStreams in the muxer contexts</span>
<span class="hl com"> * for getting unique dynamic payload types.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ac array of AVFormatContexts describing the RTP streams. If the</span>
<span class="hl com"> *           array is composed by only one context, such context can contain</span>
<span class="hl com"> *           multiple AVStreams (one AVStream per RTP stream). Otherwise,</span>
<span class="hl com"> *           all the contexts in the array (an AVCodecContext per RTP stream)</span>
<span class="hl com"> *           must contain only one AVStream.</span>
<span class="hl com"> * &#64;param n_files number of AVCodecContexts contained in ac</span>
<span class="hl com"> * &#64;param buf buffer where the SDP will be stored (must be allocated by</span>
<span class="hl com"> *            the caller)</span>
<span class="hl com"> * &#64;param size the size of the buffer</span>
<span class="hl com"> * &#64;return 0 if OK, AVERROR_xxx on error</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_sdp_create</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ac<span class="hl opt">[],</span> <span class="hl kwb">int</span> n_files<span class="hl opt">,</span> <span class="hl kwb">char</span> <span class="hl opt">*</span>buf<span class="hl opt">,</span> <span class="hl kwb">int</span> size<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Return a positive value if the given filename has one of the given</span>
<span class="hl com"> * extensions, 0 otherwise.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param filename   file name to check against the given extensions</span>
<span class="hl com"> * &#64;param extensions a comma-separated list of filename extensions</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">av_match_ext</span><span class="hl opt">(</span><span class="hl kwb">const char</span> <span class="hl opt">*</span>filename<span class="hl opt">,</span> <span class="hl kwb">const char</span> <span class="hl opt">*</span>extensions<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Test if the given container can store a codec.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ofmt           container to check for compatibility</span>
<span class="hl com"> * &#64;param codec_id       codec to potentially store in container</span>
<span class="hl com"> * &#64;param std_compliance standards compliance level, one of FF_COMPLIANCE_*</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.</span>
<span class="hl com"> *         A negative number if this information is not available.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_query_codec</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVOutputFormat <span class="hl opt">*</span>ofmt<span class="hl opt">,</span> <span class="hl kwb">enum</span> AVCodecID codec_id<span class="hl opt">,</span>
                         <span class="hl kwb">int</span> std_compliance<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;defgroup riff_fourcc RIFF FourCCs</span>
<span class="hl com"> * &#64;{</span>
<span class="hl com"> * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are</span>
<span class="hl com"> * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the</span>
<span class="hl com"> * following code:</span>
<span class="hl com"> * &#64;code</span>
<span class="hl com"> * uint32_t tag = MKTAG(&apos;H&apos;, &apos;2&apos;, &apos;6&apos;, &apos;4&apos;);</span>
<span class="hl com"> * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };</span>
<span class="hl com"> * enum AVCodecID id = av_codec_get_id(table, tag);</span>
<span class="hl com"> * &#64;endcode</span>
<span class="hl com"> */</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span><span class="hl kwd">avformat_get_riff_video_tags</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;return the table mapping RIFF FourCCs for audio to AVCodecID.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span><span class="hl kwd">avformat_get_riff_audio_tags</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;return the table mapping MOV FourCCs for video to libavcodec AVCodecID.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span><span class="hl kwd">avformat_get_mov_video_tags</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>
<span class="hl com">/**</span>
<span class="hl com"> * &#64;return the table mapping MOV FourCCs for audio to AVCodecID.</span>
<span class="hl com"> */</span>
<span class="hl kwb">const struct</span> AVCodecTag <span class="hl opt">*</span><span class="hl kwd">avformat_get_mov_audio_tags</span><span class="hl opt">(</span><span class="hl kwb">void</span><span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the sample aspect ratio of a frame, based on both the stream and the</span>
<span class="hl com"> * frame aspect ratio.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Since the frame aspect ratio is set by the codec but the stream aspect ratio</span>
<span class="hl com"> * is set by the demuxer, these two may not be equal. This function tries to</span>
<span class="hl com"> * return the value that you should use if you would like to display the frame.</span>
<span class="hl com"> *</span>
<span class="hl com"> * Basic logic is to use the stream aspect ratio if it is set to something sane</span>
<span class="hl com"> * otherwise use the frame aspect ratio. This way a container setting, which is</span>
<span class="hl com"> * usually easy to modify can override the coded value in the frames.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param format the format context which the stream is part of</span>
<span class="hl com"> * &#64;param stream the stream which the frame is part of</span>
<span class="hl com"> * &#64;param frame the frame with the aspect ratio to be determined</span>
<span class="hl com"> * &#64;return the guessed (valid) sample_aspect_ratio, 0/1 if no idea</span>
<span class="hl com"> */</span>
AVRational <span class="hl kwd">av_guess_sample_aspect_ratio</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>format<span class="hl opt">,</span> AVStream <span class="hl opt">*</span>stream<span class="hl opt">,</span> AVFrame <span class="hl opt">*</span>frame<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Guess the frame rate, based on both the container and codec information.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ctx the format context which the stream is part of</span>
<span class="hl com"> * &#64;param stream the stream which the frame is part of</span>
<span class="hl com"> * &#64;param frame the frame for which the frame rate should be determined, may be NULL</span>
<span class="hl com"> * &#64;return the guessed (valid) frame rate, 0/1 if no idea</span>
<span class="hl com"> */</span>
AVRational <span class="hl kwd">av_guess_frame_rate</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>ctx<span class="hl opt">,</span> AVStream <span class="hl opt">*</span>stream<span class="hl opt">,</span> AVFrame <span class="hl opt">*</span>frame<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Check if the stream st contained in s is matched by the stream specifier</span>
<span class="hl com"> * spec.</span>
<span class="hl com"> *</span>
<span class="hl com"> * See the &quot;stream specifiers&quot; chapter in the documentation for the syntax</span>
<span class="hl com"> * of spec.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;return  &gt;0 if st is matched by spec;</span>
<span class="hl com"> *          0  if st is not matched by spec;</span>
<span class="hl com"> *          AVERROR code if spec is invalid</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;note  A stream specifier can match several streams in the format.</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_match_stream_specifier</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">,</span> AVStream <span class="hl opt">*</span>st<span class="hl opt">,</span>
                                    <span class="hl kwb">const char</span> <span class="hl opt">*</span>spec<span class="hl opt">);</span>

<span class="hl kwb">int</span> <span class="hl kwd">avformat_queue_attached_pictures</span><span class="hl opt">(</span>AVFormatContext <span class="hl opt">*</span>s<span class="hl opt">);</span>

<span class="hl ppc">#if FF_API_OLD_BSF</span>
<span class="hl com">/**</span>
<span class="hl com"> * Apply a list of bitstream filters to a packet.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param codec AVCodecContext, usually from an AVStream</span>
<span class="hl com"> * &#64;param pkt the packet to apply filters to. If, on success, the returned</span>
<span class="hl com"> *        packet has size == 0 and side_data_elems == 0, it indicates that</span>
<span class="hl com"> *        the packet should be dropped</span>
<span class="hl com"> * &#64;param bsfc a NULL-terminated list of filters to apply</span>
<span class="hl com"> * &#64;return  &gt;=0 on success;</span>
<span class="hl com"> *          AVERROR code on failure</span>
<span class="hl com"> */</span>
attribute_deprecated
<span class="hl kwb">int</span> <span class="hl kwd">av_apply_bitstream_filters</span><span class="hl opt">(</span>AVCodecContext <span class="hl opt">*</span>codec<span class="hl opt">,</span> AVPacket <span class="hl opt">*</span>pkt<span class="hl opt">,</span>
                               AVBitStreamFilterContext <span class="hl opt">*</span>bsfc<span class="hl opt">);</span>
<span class="hl ppc">#endif</span>

<span class="hl kwb">enum</span> AVTimebaseSource <span class="hl opt">{</span>
    AVFMT_TBCF_AUTO <span class="hl opt">= -</span><span class="hl num">1</span><span class="hl opt">,</span>
    AVFMT_TBCF_DECODER<span class="hl opt">,</span>
    AVFMT_TBCF_DEMUXER<span class="hl opt">,</span>
<span class="hl ppc">#if FF_API_R_FRAME_RATE</span>
    AVFMT_TBCF_R_FRAMERATE<span class="hl opt">,</span>
<span class="hl ppc">#endif</span>
<span class="hl opt">};</span>

<span class="hl com">/**</span>
<span class="hl com"> * Transfer internal timing information from one stream to another.</span>
<span class="hl com"> *</span>
<span class="hl com"> * This function is useful when doing stream copy.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param ofmt     target output format for ost</span>
<span class="hl com"> * &#64;param ost      output stream which needs timings copy and adjustments</span>
<span class="hl com"> * &#64;param ist      reference input stream to copy timings from</span>
<span class="hl com"> * &#64;param copy_tb  define from where the stream codec timebase needs to be imported</span>
<span class="hl com"> */</span>
<span class="hl kwb">int</span> <span class="hl kwd">avformat_transfer_internal_stream_timing_info</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVOutputFormat <span class="hl opt">*</span>ofmt<span class="hl opt">,</span>
                                                  AVStream <span class="hl opt">*</span>ost<span class="hl opt">,</span> <span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>ist<span class="hl opt">,</span>
                                                  <span class="hl kwb">enum</span> AVTimebaseSource copy_tb<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * Get the internal codec timebase from a stream.</span>
<span class="hl com"> *</span>
<span class="hl com"> * &#64;param st  input stream to extract the timebase from</span>
<span class="hl com"> */</span>
AVRational <span class="hl kwd">av_stream_get_codec_timebase</span><span class="hl opt">(</span><span class="hl kwb">const</span> AVStream <span class="hl opt">*</span>st<span class="hl opt">);</span>

<span class="hl com">/**</span>
<span class="hl com"> * &#64;}</span>
<span class="hl com"> */</span>

<span class="hl ppc">#endif</span> <span class="hl com">/* AVFORMAT_AVFORMAT_H */</span><span class="hl ppc"></span>
</pre>
</body>
</html>
<!--HTML generated by highlight 3.41, http://www.andre-simon.de/-->
